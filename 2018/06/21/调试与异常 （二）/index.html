<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="调试与异常 （二）"><meta name="keywords" content=""><meta name="author" content="梁言,undefined"><meta name="copyright" content="梁言"><title>调试与异常 （二） | Hexo</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/css/reveal.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/css/theme/black.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/lib/css/zenburn.min.css"></head><body><div class="reveal"><div class="slides"><section data-markdown data-separator="---" data-separator-vertical="--" data-charset="utf-8"><script type="text/template">
### 调试与异常 （二）

#### 概念

1. 反调试的目的是什么？

   - 阻拦逆向工作者分析自己的代码

2. 什么是静态反调试？什么是动态反调试？分别都有那些？

   静态的只要在开始破解一次就可解除全部反调试限制。

   - PEB（进程环境块）

   > ```C 
   > mov   eax,   dword ptr  FS:[0x30]           //直接获取PEB的地址，
   > 或者
   > mov   eax,  dword ptr  Fs:[0x18]            //TEB的起始地址
   > mov   eax , dword  ptr  ds:[eax+30]      	//PEB的地址
   > ```
   >
   > - BeingDebugged(0x2)：调试标记位
   >
   > > 调试状态下，PEB.BeingDebugged 成员（0x2）的值设置为1。
   > > 非调试状态下，其值设置为0.
   > > IsDebuggerPresent()  API 来获取PEB.BeingDebugged的值来判断进程是否处于被调试状态。
   > >
   > > **破解之法：**
   > >
   > > 借助ollydbg调试器的编辑功能，将PEB.BeingDebugged的值修改为0即可
   >
   > - ldr(0xc)：内存状态
   >
   > >调试进程时，堆内存中会出现一些特殊标识，表示正处于被调试状态，其中最醒目的就是未使用的堆内存区域全部填充着0xFEEEFEEE。根据这一原理，我们可以判断进程是否处于调试状态。
   > >根据相应的偏移位置找到PEB.ldr位置，查找0xFEEEFEEE，
   > >
   > >**破解之法：**
   > >
   > >将填充着0xFEEEFEEE的区域全部覆盖为NULL即可
   > >注意：该方法只适用windows xp系统，在vista 之后的系统则无法使用。另外，利用附加进程将运行中的进程附加到调试器，堆内存也不会出现上述标识。
   >
   > - Process  Heap（0x18）：堆状态
   >
   > > PEB.ProcessHeap成员是指向HEAD结构体的指针。其中比较重要的是Flags(+0xC)成员和Force Flags(+0x10).
   > >
   > > ```c++
   > > mov   eax,  dword ptr  fs:[0x18]            //TEB的起始地址
   > > mov   eax , dword  ptr  ds:[eax+30]      //PEB的地址
   > > mov   eax , dword  ptr  ds:[eax+18]      //PEB.Processheap的地址。
   > > ```
   > >
   > > 进程正常运行时，heap.flags的值为0x2.heap.Forceflags的值为0x0.。进程被调试时这些值都会改变。所以比较这些值就可以判断进程是否被调试。
   > >
   > > **破解之法：**
   > >
   > > 将heap.flags的值修改为0x2.   heap.Forceflags的值修改为0x0。
   > > 注意：该方法只适用windows xp系统，在win7之后的系统则无法使用。另外，利用附加进程将运行中的进程附加到调试器，堆内存也不会出现上述标识。
   >
   > - NtGlobalFlag(0x68)：全局标记
   >
   > >调试进程时，PEB.NtGlobalFlag成员的值会被设置为0x70.所以检测该成员的值即可判断是否处于被调试状态。NtGlobalFlag 0x70是flags值进行位或运算的结果。
   > >被调试进程的堆内存中存在特殊标识，所以在成员中添加了上述标识。
   > >
   > >**破解之法：**
   > >
   > >将PEB.NtGlobalFlag的值设为0即可。

   - 使用原始API

   > - NtqueryInformationProcess()
   >
   >   通过NtqueryInformationProcess  API可以获取各种与进程调试相关的信息。
   >   函数定义中有几个重要的成员:
   >
   >   > ProcessDebugPort(0x7)：获取调试端口
   >   >
   >   > ProcessDebugObjectHandle(0x1E)：获取调试句柄
   >   >
   >   > ProcessDebugFlags(0x1F)：获取调试标记
   >   >
   >   > **破解**
   >   >
   >   > 使用CheckRemoteDebuggerPresent() API,可以查看是否调用NtqueryInformationProcess()。
   >
   > > - ProcessDebugPort(0x7)：获取调试端口
   > >
   > > >  进程处于调试状态，系统会为它分配一个调试端口，ProcessInformationClass参数的值为ProcessDebugPort（0 x7）, 若程序处于非调试状态，则变量dwDebugPort的值设置为0，若进程处于调试状态，则值设置为0xFFFFFFF.
   > >
   > > - ProcessDebugObjectHandle(0x1E)：获取调试句柄
   > >
   > > > 调试进程时会生成调试对象，函数的第二个参数值为ProcessDebugObjectHandle，调用参数后就能获取调试对象句柄，进程处于调试状态时，调试对象句柄的值就存在，若进程处于非调试状态，则调试对象句柄值为NULL.
   > >
   > > - ProcessDebugFlags(0x1F)：获取调试标记
   > >
   > > > 检测debug flag调试标志的值也可以判断是否处于被调试状态，函数 的第二个参数设置为processdebugflag(0x1)时，调用函数后通过第三个参数即可获的调试标志的值，若为0，则进程处于被调试状态，若为1，则进程处于非调试状态。
   >
   > - NtquerySystemInformation()
   >
   >   ntdll!NtquerySystemInformation（）API是一个系统函数，用来获取当前运行的多种OS信息。
   >
   > > - 向SystemInformationclass参数传入Systemkerneldebuggerinformation的值（0X23）即可判断出当前系统是否处于调试模式下进行。
   > >   当API返回时，若系统处在调试模式下，第二个参数的值设置为1，
   > >   **破解之法：**
   > >
   > >   > windows xp系统中编辑boot.ini文件，删除  "/debugport=com1 /baudrate=115200  /Debug"值。
   > >
   > >   > windows 7系统的命令窗口执行bsdedit/debug off 命令即可。并且若重启系统则要以正常模式启动。
   >
   > - NTQueryObject()
   >
   >   系统中的某个调试器调试进程时，会创建一个调试对象类型的内核对象。检测该对象是否存在课判断是否有进程正在被调试。
   >
   >   > ntdll!NtqueryObject()API用来获取各种内核对象的信息
   >
   >   > **破解之法：**钩取API
   >
   > - ZwSetInformationThread()
   >
   >   强制分离被调试者和调试器的技术。利用ZwSetInformationThread()API可将被调试者和调试器分离出来。
   >
   >   > 该函数是一个原生API,用来为线程设置信息的，有两个参数，一是用来接收线程的句柄，二是表示线程信息类型，若其值设置为threadhideformdebugger(0x11),调用该函数后，调试进程就会被分离出来。
   >
   >   > **破解之法：**
   >   >
   >   > 把threadhideformdebugger(0x11)的值修改为0后继续运行即可。当然也可以钩取相应的API.
   >   >
   >   > 提示：其工作原理是将线程隐藏起来，调试器就接收不到信息，从而无法调试。而且，windows Xp之后新增了DebugActiveProcessstop（)API.

   - TLS回调函数
   - ETC

   > 很多反调试技术是借助win32API获取系统信息来实现。
   > 检测ollydbg窗口       findWindow()
   > 检测ollydbg进程        createToolhelp32snapshot（）
   > 检测计算机名称是否为“Test”，“analysis”,等   getcomputername()
   > 检测程序运行路径中是否存在“test”,"sample".等名称   getcomandline()
   > 检测虚拟机是否处于运行状态，虚拟机特有的进程名称   vmwareservice.exe   vmwareTray.exe  vmwareUser.exe

   - 攻击调试器

   > - NtSetInformationThread()
   >   - ThreadHideFormDebugger(0x11)

   - 打开进程检查

   > - SeDebugPrivilege：检查进程是否具有调试权限

#### 实验

- SHE反调试

```c++
// SEH_AntiDebug_Native.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <windows.h>
#pragma warning(disable: 4733) // 忽略“内联 asm 分配到FS:0”错误
void (*g_funExceptionReturn)() = nullptr;



void RightFun()
{
    MessageBox(0,L"正常运行！",L"SEH反调试测试",MB_OK);
    // 删除异常处理器
    //     运行至此处时栈顶的信息是EXCEPTION_REGISTRATION_RECORD，里面
    // 保存着其最初运行的已成处理器，我们将其保存到FS:[0]处后就相当于
    // 摘除了前面注册的SEH异常链信息。
    __asm pop dword ptr fs:[0];
    g_funExceptionReturn();
}



void WrongFun()
{
    MessageBox(0,L"检测到调试器！",L"SEH反调试测试",MB_OK);
    // 删除异常处理器
    //     运行至此处时栈顶的信息是EXCEPTION_REGISTRATION_RECORD，里面
    // 保存着其最初运行的已成处理器，我们将其保存到FS:[0]处后就相当于
    // 摘除了前面注册的SEH异常链信息。
    __asm pop dword ptr fs:[0];
}



EXCEPTION_DISPOSITION ExpHandel_A(
    EXCEPTION_RECORD              *pExceptionRecord,   // 异常状态描述
    EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,  // 异常注册框架
    CONTEXT                       *pContextRecord,     // 返回线程上下文
    PVOID                         pDispatcherContext ) // 分发器上下文（系统使用，无需关注）
{
    // 1. 获取调试标志位
    BYTE IsBeginDebug = false; 
    __asm {
        push eax;
        mov eax, dword ptr fs:[0x30]; // 获取PEB
        mov al,byte ptr ds:[eax+2]; // 获取PEB.BeginDebug
        mov IsBeginDebug,al;
        pop eax;
    };
	
    // 2. 备份正确的异常返回地址
    g_funExceptionReturn = (void (*)())pContextRecord->Eip;

    // 3. 根据标志位执行不同的SEH异常处理流程
    if ( IsBeginDebug )
        pContextRecord->Eip = (DWORD)WrongFun;
    else
        pContextRecord->Eip = (DWORD)RightFun;

    // 4. 返回“已经正常处理”
    return ExceptionContinueExecution;
}



EXCEPTION_DISPOSITION ExpHandel_B(
    EXCEPTION_RECORD              *pExceptionRecord,   // 异常状态描述
    EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,  // 异常注册框架
    CONTEXT                       *pContextRecord,     // 返回线程上下文
    PVOID                         pDispatcherContext ) // 分发器上下文（系统使用，无需关注）
{
    // 返回“运行下一个异常处理器”
    return ExceptionContinueSearch;
}


int _tmain(int argc, _TCHAR* argv[])
{
    // 1. 添加SEH异常链
    // 以下异常链添加完成后为：
    // [Start]                                                                  [End]
    // *-------------*    *-------------*    *------------*            *------------* 
    // | Next -------+--> | Next -------+--> | Next ------+--> ... --> | 0xFFFFFFFF |
    // | ExpHandel_B |    | ExpHandel_A |    | ?????????? |            | ?????????? |    
    // *-------------*    *-------------*    *------------*            *------------*    
	__asm{ /* 添加SEH异常链A */ 
        push ExpHandel_A;
        push dword ptr fs:[0];
        mov dword ptr fs:[0],esp;
    };
    __asm{ /* 添加SEH异常链B */   
        push ExpHandel_B;
        push dword ptr fs:[0];
        mov dword ptr fs:[0],esp;
    };

    // 2. 人为制造异常
    int *pTest = nullptr;
    *pTest = 0;

	return 0;
}
```

</script></section></div></div><script src="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/lib/js/head.min.js"></script><script src="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/js/reveal.min.js"></script><script>Reveal.initialize({
  mouseWheel: false,
  transition: 'slide',
  transitionSpeed: 'default',
  parallaxBackgroundImage: '',
  parallaxBackgroundSize: '',
  parallaxBackgroundHorizontal: '',
  parallaxBackgroundVertical: '',
  markdown: {
    smartypants: true
  },
  dependencies: [
    { src: '/js/third-party/reveal/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: '/js/third-party/reveal/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    // Syntax highlight for <code> elements
    { src: '/js/third-party/reveal/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    // Zoom in and out with Alt+click
    { src: '/js/third-party/reveal/zoom.min.js', async: true },
    // Speaker notes
    { src: '/js/third-party/reveal/notes.min.js', async: true },
    // MathJax
    { src: '/js/third-party/reveal/math.min.js', async: true }
  ]
});</script></body></html>