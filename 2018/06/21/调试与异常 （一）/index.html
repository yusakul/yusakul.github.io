<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="调试与异常 （一）"><meta name="keywords" content=""><meta name="author" content="梁言,undefined"><meta name="copyright" content="梁言"><title>调试与异常 （一） | Hexo</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/css/reveal.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/css/theme/black.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/lib/css/zenburn.min.css"></head><body><div class="reveal"><div class="slides"><section data-markdown data-separator="---" data-separator-vertical="--" data-charset="utf-8"><script type="text/template">
### 调试与异常 （一）

#### 一、概念

1. 什么是IDT？

   - 中断描述符表（IDT），当中断和异常发生时，CPU通过查找IDT表来定位处理例程的地址，然后转去执行该处例程。

2. 异常分发有几轮？

   - 内核态异常的分发过程

     对于第一轮异常KiDispatchException会试图先通知内核调试器来处理异常，如果没有处理异常，那么会调用RtlDispatchExcption，试图寻找已经注册的结构化异常处理器（SEH）。

     如果也没有找到，那么就会给内核调试器第二次处理的机会。仍然返回FLASE的话，就会调用KeBugCheckEx触发蓝屏。

   - 用户态异常的分发过程

     首先，KiDispatchException会判断是否发送给内核调试器，但内核调试器通常不处理用户态异常，所以KiDispatchException会试图发送给用户态调试器，方法是调用DbgkForwardException。如果不成功，KiDispatchException下一步动作是试图寻找异常处理块来处理该异常，因为用户异常发生在用户态代码中，异常处理块也是在用户态代码中。所以需要转到用户态去执行。（这也就是相对于内核态异常的分发过程，用户态异常的分发过程会麻烦一点的原因，具体方式不再累赘，参考《软件调试》）如果最终也返回FALSE，那么就会分发第二轮。

3. 产生了异常，是先发送给调试器处理，还是先被程序的异常处理机制处理掉？

   - 先发送给调试器


#### 二、编程

1. 使用DLL注入 + VEH 的方式，处理异常程序的异常

   - test.cpp

   ````c++
   #include "stdafx.h"
   #include <process.h>
   
   int main()
   {
   	printf("输入\n");
   	int a, b;
   	scanf_s("%d", &a);
   	b = 1 / a;
   	printf("%d\n", b);
   	system("pause");
       return 0;
   }
   ````

   - dllmain.dll

   ```c++
   // dllmain.cpp : 定义 DLL 应用程序的入口点。
   #include "stdafx.h"
   #include "stdio.h"
   #include "windows.h"
   
   LONG WINAPI veh(EXCEPTION_POINTERS* pExce)
   {
   	if (pExce->ExceptionRecord->ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO)
   	{
   		pExce->ContextRecord->Eip += 3;
   		printf("fdsf\n");
   	return EXCEPTION_CONTINUE_EXECUTION;
   	}
   
   	return EXCEPTION_CONTINUE_SEARCH;
   } 
   
   BOOL APIENTRY DllMain( HMODULE hModule,
                          DWORD  ul_reason_for_call,
                          LPVOID lpReserved
                        )
   {
   	switch (ul_reason_for_call)
   	{
   	case DLL_PROCESS_ATTACH:
   		//1. 将异常处理函数注册到系统
   		AddVectoredExceptionHandler(TRUE, veh);
   		printf("注册异常处理函数成功！\n");
   		break;
   	case DLL_THREAD_ATTACH:
   		break;
   	case DLL_THREAD_DETACH:
   		break;
   	case DLL_PROCESS_DETACH:
   		break;
   	}
   	return TRUE;
   }
   ```

   - 注入器

   ```C++
   // 远程注入.cpp: 定义控制台应用程序的入口点。
   //
   
   #include "stdafx.h"
   #include "windows.h"
   
   
   bool injectDll(DWORD dwPid, const char* pszDllPath);
   
   int main()
   {
   	DWORD dwPid;
   	char szDllPath[MAX_PATH] = { "C:\\Users\\Administrator\\source\\repos\\VEH_Dll\\Debug\\VEH_Dll.dll"};
   
    	printf("输入要注入到的进程PID：");
    	scanf_s("%d[*]", &dwPid);
   
   	injectDll(dwPid, szDllPath);
       return 0;
   }
   
   bool injectDll(DWORD dwPid, const char* pszDllPath)
   {
   	bool	bRet = false;
   	HANDLE	hProcess = 0;
   	HANDLE	hRemoteThread = 0;
   	LPVOID	pRemoteBuff = NULL;
   	SIZE_T 	dwWrite = 0;
   	DWORD	dwSize = 0;
   
   	//打开进程
   	hProcess = OpenProcess(
   		PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,/*创建线程和写入内存权限*/
   		FALSE, dwPid/*进程ID*/);
   
   	if (hProcess == NULL)
   	{
   		printf("打开进程失败,可能由于本程序的权限太低,请以管理员身份运行再尝试\n");
   		goto _EXIT;
   	}
   
   	
   	//1. 在远程进程上开辟内存空间
   	pRemoteBuff = VirtualAllocEx(
   		hProcess,
   		NULL,
   		64*1024,/*大小：64Kb*/
   		MEM_COMMIT,/*预定并提交*/
   		PAGE_EXECUTE_READWRITE/*可读可写可执行的属性*/
   		);
   	if (pRemoteBuff == NULL)
   	{
   		printf("在远程进程上开辟空降失败\n");
   		goto _EXIT;
   	}
   
   
   	//2. 将DLL路径写入到新开的内存空间中
   	dwSize = strlen(pszDllPath) + 1;
   	WriteProcessMemory(
   		hProcess,
   		pRemoteBuff,/* 要写入的地址 */
   		pszDllPath,	/* 要写入的内容的地址*/
   		dwSize,		/* 写入的字节数 */
   		&dwWrite	/* 输入：函数实际写入的字节数*/
   	);
   
   	if (dwWrite != dwSize)
   	{
   		printf("写入Dll路径失败\n");
   		goto _EXIT;
   	}
   
   
   	//3. 创建远程线程
   	//   远程线程创建成功后,DLL就会被加载,DLL被加载后DllMain函数
   	//	 就会被执行,如果想要执行什么代码,就在DllMain中调用即可.
   
   	hRemoteThread = CreateRemoteThread(
   		hProcess,
   		0, 0,
   		(LPTHREAD_START_ROUTINE)LoadLibraryA,  /* 线程回调函数 */
   		pRemoteBuff,							/* 回调函数参数 */
   		0, 0);
   
   	// 等待远程线程退出.
   	// 退出了才释放远程进程的内存空间.
   	WaitForSingleObject(hRemoteThread, -1);
   
   
   	bRet = true;
   
   
   _EXIT:
   	// 释放远程进程的内存
   	VirtualFreeEx(hProcess, pRemoteBuff, 0, MEM_RELEASE);
   	// 关闭进程句柄
   	CloseHandle(hProcess);
   
   	return bRet;
   }
   ```

2. 验证异常处理调用顺序：VEH --> SEH --> VCH

   ~~~~~~c++
   #include "stdafx.h"
   #include <windows.h>
   
   LONG WINAPI vch(EXCEPTION_POINTERS* pExcept)
   {
       printf("vch\n");
       return EXCEPTION_CONTINUE_SERCH;
   }
   
   LONG WINAPI veh(EXCEPTION_POINTERS* pExcept)
   {
       printf("veh\n");
       return EXCEPTION_CONTINUE_SEARCH;
   }
   
   LONG WINAPI seh(EXCEPTION_POINTERS* pExcept)
   {
       printf("seh\n");
       return EXCEPTION_CONTINUE_SEARCH;
   }
   
   LONG WINAPI ueh(EXCEPTION_POINTERS* pExcept)
   {
       printf("ueh\n");
       return EXCEPTION_CONTINUE_SEARCH;
   }
   
   int _tmain(int argc, _TCHAR* argv[])
   {
       AddVectoredContinueHandler(TRUE, vch);
       AddVectoreExceptionHandler(TRUE, veh);
       //在64位系统系下，当程序被调用时，UEH不会被调用，不被调试才会被调用
       //在32位系统下，被调试时也会被调用
       SetUnhandledExceptionFilter(ueh);
       __try{
           *(int*)0=0;
       }
       __except(seh(GetExceptionInformation())){
       }
       return 0;
   }
   ~~~~~~

3. 分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher。

   - KiTrap03：

   > - （1）处理int3异常的函数为KITrap03
   > - （2）在开始异常处理之初，先构造TRAP_FRAME陷阱帧结构，陷阱帧是指一个结构体，用来保存系统调用、中断、异常发生时的寄存器现场，方便以后回到用户空间 / 回到中断处时，回复那些寄存器的值，继续执行
   > - （3）注意到KiTrap03实际上调用了CommonDispatchException

   - CommonDisPatchException：

   > - （1）判断是用户异常还是内核异常使用的是CS段寄存器的最后两位
   > - （2）构件了一个异常记录的结构
   > - （3）之后实际上调用了KiDispatchException来处理异常

   - KiDispatchException：

   > - （1）该函数用于分发异常，根据异常所产生的模式找到异常的函数
   > - （2）如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常
   > - （3）如果异常发生在用户模式，则函数会将异常记录、异常栈帧 和 陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常。

   - KiUserExceptionDispatcher：

   > - （1）函数第一个参数为异常类型，第二个参数为产生异常时的上下文记录
   > - （2）KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。
</script></section></div></div><script src="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/lib/js/head.min.js"></script><script src="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/js/reveal.min.js"></script><script>Reveal.initialize({
  mouseWheel: false,
  transition: 'slide',
  transitionSpeed: 'default',
  parallaxBackgroundImage: '',
  parallaxBackgroundSize: '',
  parallaxBackgroundHorizontal: '',
  parallaxBackgroundVertical: '',
  markdown: {
    smartypants: true
  },
  dependencies: [
    { src: '/js/third-party/reveal/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: '/js/third-party/reveal/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    // Syntax highlight for <code> elements
    { src: '/js/third-party/reveal/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    // Zoom in and out with Alt+click
    { src: '/js/third-party/reveal/zoom.min.js', async: true },
    // Speaker notes
    { src: '/js/third-party/reveal/notes.min.js', async: true },
    // MathJax
    { src: '/js/third-party/reveal/math.min.js', async: true }
  ]
});</script></body></html>