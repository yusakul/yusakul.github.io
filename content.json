{"meta":{"title":"梁言","subtitle":null,"description":null,"author":"yusakul","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-21T13:10:11.000Z","updated":"2018-06-21T13:10:51.701Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-21T13:09:20.000Z","updated":"2018-06-21T13:09:54.271Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AndroidStudio附加动态调试smali","slug":"AndroidStudio动态调试smali","date":"2018-07-06T02:30:28.000Z","updated":"2018-07-06T10:26:56.761Z","comments":true,"path":"2018/07/06/AndroidStudio动态调试smali/","link":"","permalink":"http://yoursite.com/2018/07/06/AndroidStudio动态调试smali/","excerpt":"","text":"本文参照至吾爱破解https://www.52pojie.cn/thread-658865-1-1.html AndroidStudio动态调试smali配置操作稍微有些繁琐，为了加深印象，同时方便日后翻阅查询，所以有了这篇博客。 1、环境与工具 AndroidStudio V3.2beta1 smaliidea——AndroidStudio插件 链接：https://pan.baidu.com/s/1htl26qS 密码：0pre AndroidKiller V1.3.1.0 jdk1.8.0_171 2、安装smaliidea插件 3、AndroidKiller分析apk将目标apk文件拖入到AndroidKiller中分析，找到要调试APK的包名和入口的Activity 记住包名ctf.bobdylan 和入口的Activity名 ctf.bobbydylan.M 这里要注意一下 在application标签里面要有 android:debuggable=”true” 这句代码，没有是不能调试apk的 现在调试的这个例子默认是有这句代码的 有的apk中没有这句代码要自行添加上 然后找到该文件的工程目录，此目录将被AndroidStudio导入。 4、导入工程到AndroidStudio，以及AndroidStudio配置可以直接导入上面的工程目录，当时我们还是做个拷贝吧。 选择整个工程目录导入，然后一直保持默认配置点next即可，导入后切换到工程视图。 选择smali目录作为资源目录，见下图 配置远程调试的选项，选择Run–&gt;Edit Configurations 并增加一个Remote调试的调试选项，端口选择:8700 5、监听端口：打开模拟器与Monitor模拟器我这里选择的是AndroidStudio自带的，把自己要调试的APK安装到手机模拟器中。 打开命令行 输入命令 : adb shell am start -D -n ctf.bobdylan/ctf.bobbydylan.M 对apk进行动态调试 这条命令运行后手机屏幕将会进入到调试界面(如果手机屏幕没有进入到调试界面说明USB没有连接好手机 或者USB调试模式 没有打开 或者其他原因) ，手机将自动运行被调试App 因为新版AndroidStudio已经在菜单中移除了Monitor，我们需要手动在SDK文件夹中找到Monitor，同时Monitor不支持JDK8以上的版本，比如JDK10。如下为我的Monitor路径，请根据自己SDK安装情况查找。 E:\\Sdk\\tools\\lib\\monitor-x86_64\\monitor.exe 查看Android Device Monitor 记住下图中Online对应的值12863， 然后把Android Device Monitor关掉(这里一定要关掉,因为它会占用8700端口 导致后面转发端口失败) 打开命令行窗口 输入命令 adb forward tcp:8700 jdwp:12863 转发8700 端口 (这里 jdwp是自己Android Device Monitor中要调试app的Online值 ) ，连接成功后如下图所示 在Smali中下好断点 断点的意思是程序运行到下断点的那行代码就会断下来 ，我们找到入口类ctf.bobbydylan.M” 下好断点之后Run–&gt;Attach to Local Process附加进程，这里的smali是我们之前配置好的调试选项 此时手机会进入程序 在手机上输入用户名和密码 点登陆 程序会断在我下的断点处 单步调试为F8，运行为F9。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android逆向分析","slug":"Android逆向分析","permalink":"http://yoursite.com/tags/Android逆向分析/"}]},{"title":"Android Crackme","slug":"Android Crackme","date":"2018-07-05T00:41:56.000Z","updated":"2018-07-05T02:05:11.290Z","comments":true,"path":"2018/07/05/Android Crackme/","link":"","permalink":"http://yoursite.com/2018/07/05/Android Crackme/","excerpt":"","text":"接触安卓逆向拿来练手的第一个小程序 分析程序链接: https://pan.baidu.com/s/18kWNe-IH26m5GpQnZOkiNw 密码: jy2m分析工具：Android Killer模拟器：夜神模拟器 安装后输入随机输入密码查看验证提示很显然，可以搜索字符串”错误”、”OK”来定位到关键代码。不过Android Killer提供了检索列出所有字符串的功能…，很方便的得到如下信息。双击进入，看到错误分支在异常处理中再上java源码~大致流程为获取输入字符串，传入check方法中，如不抛出异常，则验证成功。下面贴上check方法代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package ctf.bobbydylan;import android.content.Intent;import android.os.Bundle;import android.widget.Button;import android.widget.TextView;import ctf.bobdylan.R;public class M extends T &#123; public void check(String str) &#123; int i = 0; if (str.length() != 16) &#123; throw new RuntimeException(); &#125; String str2 = \"\"; try &#123; str2 = getKey(); &#125; catch (Exception e) &#123; str2 = getKey(); System.arraycopy(str2, 0, str, 5, 5); &#125; int[] iArr = new int[16]; iArr[0] = 0; iArr[12] = 14; iArr[10] = 7; iArr[14] = 15; iArr[15] = 42; try &#123; iArr[1] = 3; iArr[5] = 5; System.out.println(); &#125; catch (Exception e2) &#123; iArr[5] = 37; iArr[1] = 85; &#125; iArr[6] = 15; iArr[2] = 13; iArr[3] = 19; iArr[11] = 68; iArr[4] = 85; iArr[13] = 5; iArr[9] = 7; iArr[7] = 78; iArr[8] = 22; while (i &lt; str.length()) &#123; if ((iArr[i] &amp; 255) != ((str.charAt(i) ^ str2.charAt(i % str2.length())) &amp; 255)) &#123; throw new RuntimeException(); &#125; i++; &#125; &#125; public String getKey() &#123; return \"bobbydylan\"; &#125; public void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.main); startService(new Intent(this, P.class)); ((Button) findViewById(R.id.button)).setOnClickListener(new a(this, (TextView) findViewById(R.id.et))); &#125; protected void onPause() &#123; stopService(new Intent(this, P.class)); super.onPause(); &#125;&#125; 这里有个坑，如下图，我们一开始搜索字符串的时候就能发现有两个相似字符串，其实他们是不同类中的方法获取得到的。但是check中调用的是T类中的getkey()，其返回的字符串为”bobdylan”。 逆向获取key： 1234567891011121314151617#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; char nArray1[16] = &#123; 0, 3, 13, 19, 85, 5, 15, 78, 22, 7, 7, 68, 14, 5, 15, 42 &#125;; char nArray2[8] = &#123; 'b', 'o', 'b', 'd', 'y', 'l', 'a', 'n' &#125;; char nArray3[16] = &#123;0&#125;; for (int i = 0; i &lt; 16; i++) &#123; nArray3[i] = (nArray1[i] ^ nArray2[(i % 8) &amp;0xFF]); printf(\"%c\", nArray3[i]); &#125; printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android逆向分析","slug":"Android逆向分析","permalink":"http://yoursite.com/tags/Android逆向分析/"}]},{"title":"java文件读写操作","slug":"java文件读写操作","date":"2018-07-03T12:23:17.000Z","updated":"2018-07-03T13:12:01.204Z","comments":true,"path":"2018/07/03/java文件读写操作/","link":"","permalink":"http://yoursite.com/2018/07/03/java文件读写操作/","excerpt":"","text":"一.获得控制台用户输入的信息123456789101112131415161718public String getInputMessage() throws IOException...&#123; System.out.println(\"请输入您的命令∶\"); byte buffer[]=new byte[1024]; int count=System.in.read(buffer); char[] ch=new char[count-2];//最后两位为结束符，删去不要 for(int i=0;i&lt;count-2;i++) ch[i]=(char)buffer[i]; String str=new String(ch); return str; ｝ 可以返回用户输入的信息，不足之处在于不支持中文输入，有待进一步改进。 二.复制文件 以文件流的方式复制文件 12345678910111213141516public void copyFile(String src,String dest) throws IOException...&#123; FileInputStream in=new FileInputStream(src); File file=new File(dest); if(!file.exists()) file.createNewFile(); FileOutputStream out=new FileOutputStream(file); int c; byte buffer[]=new byte[1024]; while((c=in.read(buffer))!=-1)...&#123; for(int i=0;i&lt;c;i++) out.write(buffer[i]); &#125; in.close(); out.close(); &#125; ​ 该方法经过测试，支持中文处理，并且可以复制多种类型，比如txt，xml，jpg，doc等多种格式 三.写文件 1.利用PrintStream写文件 12345678910public void PrintStreamDemo()...&#123; try ...&#123; FileOutputStream out=new FileOutputStream(\"D:/test.txt\"); PrintStream p=new PrintStream(out); for(int i=0;i&lt;10;i++) p.println(\"This is \"+i+\" line\"); &#125; catch (FileNotFoundException e) ...&#123; e.printStackTrace(); &#125; &#125; 2.利用StringBuffer写文件 123456789101112public void StringBufferDemo() throws IOException......&#123; File file=new File(\"/root/sms.log\"); if(!file.exists()) file.createNewFile(); FileOutputStream out=new FileOutputStream(file,true); for(int i=0;i&lt;10000;i++)......&#123; StringBuffer sb=new StringBuffer(); sb.append(\"这是第\"+i+\"行:前面介绍的各种方法都不关用,为什么总是奇怪的问题 \"); out.write(sb.toString().getBytes(\"utf-8\")); &#125; out.close(); &#125; ​ 该方法可以设定使用何种编码，有效解决中文问题。 四.文件重命名1234567891011public void renameFile(String path,String oldname,String newname)...&#123; if(!oldname.equals(newname))...&#123;//新的文件名和以前文件名不同时,才有必要进行重命名 File oldfile=new File(path+\"/\"+oldname); File newfile=new File(path+\"/\"+newname); if(newfile.exists())//若在该目录下已经有一个文件和新文件名相同，则不允许重命名 System.out.println(newname+\"已经存在！\"); else...&#123; oldfile.renameTo(newfile); &#125; &#125; &#125; 五.转移文件目录 转移文件目录不等同于复制文件，复制文件是复制后两个目录都存在该文件，而转移文件目录则是转移后，只有新目录中存在该文件。 123456789101112131415public void changeDirectory(String filename,String oldpath,String newpath,boolean cover)...&#123; if(!oldpath.equals(newpath))...&#123; File oldfile=new File(oldpath+\"/\"+filename); File newfile=new File(newpath+\"/\"+filename); if(newfile.exists())...&#123;//若在待转移目录下，已经存在待转移文件 if(cover)//覆盖 oldfile.renameTo(newfile); else System.out.println(\"在新目录下已经存在：\"+filename); &#125; else...&#123; oldfile.renameTo(newfile); &#125; &#125; &#125; 六.读文件 1.利用FileInputStream读取文件 12345678910111213public String FileInputStreamDemo(String path) throws IOException...&#123; File file=new File(path); if(!file.exists()||file.isDirectory()) throw new FileNotFoundException(); FileInputStream fis=new FileInputStream(file); byte[] buf = new byte[1024]; StringBuffer sb=new StringBuffer(); while((fis.read(buf))!=-1)...&#123; sb.append(new String(buf)); buf=new byte[1024];//重新生成，避免和上次读取的数据重复 &#125; return sb.toString(); &#125; 2.利用BufferedReader读取 在IO操作，利用BufferedReader和BufferedWriter效率会更高一点 1234567891011121314public String BufferedReaderDemo(String path) throws IOException...&#123; File file=new File(path); if(!file.exists()||file.isDirectory()) throw new FileNotFoundException(); BufferedReader br=new BufferedReader(new FileReader(file)); String temp=null; StringBuffer sb=new StringBuffer(); temp=br.readLine(); while(temp!=null)...&#123; sb.append(temp+\" \"); temp=br.readLine(); &#125; return sb.toString(); &#125; 3.利用dom4j读取xml文件 12345678public Document readXml(String path) throws DocumentException, IOException...&#123; File file=new File(path); BufferedReader bufferedreader = new BufferedReader(new FileReader(file)); SAXReader saxreader = new SAXReader(); Document document = (Document)saxreader.read(bufferedreader); bufferedreader.close(); return document; &#125; 七.创建文件(文件夹) 1.创建文件夹 12345public void createDir(String path)...&#123; File dir=new File(path); if(!dir.exists()) dir.mkdir(); &#125; 2.创建新文件 123456789public void createFile(String path,String filename) throws IOException...&#123; File file=new File(path+\"/\"+filename); if(!file.exists()) file.createNewFile();&#125; 八.删除文件(目录) 1.删除文件 12345public void delFile(String path,String filename)...&#123; File file=new File(path+\"/\"+filename); if(file.exists()&amp;&amp;file.isFile()) file.delete(); &#125; 2.删除目录 要利用File类的delete()方法删除目录时，必须保证该目录下没有文件或者子目录，否则删除失败，因此在实际应用中，我们要删除目录，必须利用递归删除该目录下的所有子目录和文件，然后再删除该目录。 123456789101112131415public void delDir(String path)...&#123; File dir=new File(path); if(dir.exists())...&#123; File[] tmp=dir.listFiles(); for(int i=0;i&lt;tmp.length;i++)...&#123; if(tmp[i].isDirectory())...&#123; delDir(path+\"/\"+tmp[i].getName()); &#125; else...&#123; tmp[i].delete(); &#125; &#125; dir.delete(); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"不同语言编译的程序入口总结","slug":"各种语言编译的程序入口","date":"2018-06-30T06:23:29.000Z","updated":"2018-06-30T08:05:32.056Z","comments":true,"path":"2018/06/30/各种语言编译的程序入口/","link":"","permalink":"http://yoursite.com/2018/06/30/各种语言编译的程序入口/","excerpt":"","text":"BC++程序特征1. OEP特征 二进制特征:EB 10 66 62 3A 43 2B 2B 48 4F 4F 4B 90第一个API调用:GetModuleHandlAAPI调用IAT时，采用模式是FF25 2.区段名称 区段分类较细 3.链接器版本 5.0 Delphi程序特征1.OEP特征 5个CALL,第一个CALL内有API调用GetModulehandleA 2.区段名称 3. 链接器版本 2.25 VS程序 以链接器版本为例，分析VC程序 VC6.0 版本 VC6.0 6.0 VC2003 7.0/7.1 VC2005 8.0 VS2008 9.0 VS2010 10.0 VS2012 11.0 VS2013 12.0 VS2015 14.0 VS2017 14.0 VC6.0/易语言OEP 申请局部空间是:sub esp,0x58第一个API调用是GetVersion","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://yoursite.com/tags/逆向/"}]},{"title":"010 Editor v8.0.1_x32分析以及注册机制作","slug":"010 Editor分析","date":"2018-06-25T01:09:57.000Z","updated":"2018-07-03T12:37:16.846Z","comments":true,"path":"2018/06/25/010 Editor分析/","link":"","permalink":"http://yoursite.com/2018/06/25/010 Editor分析/","excerpt":"","text":"环境以及工具 Window7_x32 010 Editor v8.0.1_x32 OD VS2017 第一步 找到判断注册结果的关键跳转和关键函数 使用OD打开010editor，进入到注册界面，先尝试输入随意的ID和Key，获取弹出的提示信息字符串 尝试在OD中搜索如下字符 “Invalid name or password.”，搜索结果如下 发现存在大量提示信息，我们在其中找到注册成功的提示信息，（上图红框：感谢购买010editor），双击查看反汇编窗口，见下图。 往上查看判断注册成功的关键跳转 我们发现地址为00DD5926处跳转JNZ 010Edito.00DD5A58应该为关键跳转，下方可以找到输出字符串”Password accepted. This ….”， 而其跳转地址处汇编代码为输出”Password accepted….” （010editor使用QT界面库编写 ，我们可以猜测出push字符串随后的函数应为输出字符串） 回到关键跳转00DD5926处，判断密码为正确的条件为EDI = 0xDB，而EDI的值是EAX给的，而EAX为函数010Edito.00409C9B的返回值，这个函数可能为验证Key的关键函数，而我们动态调试发现有跳转直接跳转到cmp edi,0xdb。 同样为函数010Edito.00409C9B，现在可以认为这是关键函数，此时EDI的值为0x177，为了验证此跳转为关键跳转，我们把EDI的值修改为0xDB。 之后F9运行 验证成功！接下来我们进入函数分析。 第二步 分析关键函数1(返回DB为注册成功) 函数010Edito.00409C9B，参数情况为： arg1 = 0x9 ； arg2 = 0x4389； 从下往上看，找到需要的0xDB，而跳转条件是eax = 0x2D， 为函数010Edito.0040A826的返回值。 ###第三步 分析关键函数2(返回2D为注册成功) 进入函数，该函数作用为将key取出，放在在局部变量数组中，数组起始地址为ebx-24 1234567891011&gt; key[0 ] = [ebx-24]=0x12&gt; key[1 ] = [ebx-23]=0x34&gt; key[2 ] = [ebx-22]=0x56&gt; key[3 ] = [ebx-21]=0x78&gt; key[4 ] = [ebx-20]=0x90&gt; key[5 ] = [ebx-1F]=0x12&gt; key[6 ] = [ebx-1E]=0x34&gt; key[7 ] = [ebx-1D]=0x56&gt; key[8 ] = [ebx-1C]=0x78&gt; key[9 ] = [ebx-1B]=0x90&gt; 密钥数组对应如上，该处汇编代码如下，当KEY[3] == 0x9C时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&gt; 013BDC5D . 8A5D DF MOV BL,BYTE PTR SS:[EBP-0x21] ; key[3]&gt; 013BDC60 . 8A7D E1 MOV BH,BYTE PTR SS:[EBP-0x1F] ; key[5]&gt; 013BDC63 . 80FB 9C CMP BL,0x9C ; 是否等于0x9c&gt; 013BDC66 . 75 70 JNZ SHORT 010Edito.013BDCD8 ; 跳转到是否等于FC&gt; 013BDC68 . 8A45 DC MOV AL,BYTE PTR SS:[EBP-0x24] ; key[0]&gt; 013BDC6B . 3245 E2 XOR AL,BYTE PTR SS:[EBP-0x1E] ; key[0]^key[6]&gt; 013BDC6E . 8845 E8 MOV BYTE PTR SS:[EBP-0x18],AL ;&gt; 013BDC71 . 8A45 DD MOV AL,BYTE PTR SS:[EBP-0x23] ; key[1]&gt; 013BDC74 . 3245 E3 XOR AL,BYTE PTR SS:[EBP-0x1D] ; key[1]^key[7]&gt; 013BDC77 . FF75 E8 PUSH DWORD PTR SS:[EBP-0x18]&gt; 013BDC7A . 0FB6C8 MOVZX ECX,AL&gt; 013BDC7D . B8 00010000 MOV EAX,0x100&gt; 013BDC82 . 66:0FAFC8 IMUL CX,AX ; (key[1]^key[7])*0x100&gt; 013BDC86 . 8A45 DE MOV AL,BYTE PTR SS:[EBP-0x22] ; key[2]&gt; 013BDC89 . 32C7 XOR AL,BH ; key[2]^key[5]&gt; 013BDC8B . 0FB6C0 MOVZX EAX,AL&gt; 013BDC8E . 66:03C8 ADD CX,AX &gt; ;cx = (key[1]^key[7])*0x100 + key[2]^key[5]&gt; 013BDC91 . 0FB7F1 MOVZX ESI,CX&gt; 013BDC94 . E8 AB9904FF CALL 010Edito.00407644 &gt; 013BD0B0 /&gt; \\55 PUSH EBP&gt; 013BD0B1 |. 8BEC MOV EBP,ESP&gt; 013BD0B3 |. 8B45 08 MOV EAX,[ARG.1] &gt; ; eax = key[0]^key[6] &gt; 013BD0B6 |. 34 18 XOR AL,0x18 &gt; ; al = key[0]^key[6]^0x18 &gt; 013BD0B8 |. 04 3D ADD AL,0x3D &gt; ; al = key[0]^key[6]^0x18 + 0x3D&gt; 013BD0BA |. 34 A7 XOR AL,0xA7 &gt; ; al =(key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BD0BC |. 5D POP EBP &gt; 013BD0BD \\. C3 RETN&gt; &gt; 013BDC99 . 0FB6C0 MOVZX EAX,AL&gt; 013BDC9C . 56 PUSH ESI &gt; ; esi = (key[1]^key[7])*0x100 + key[2]^key[5]&gt; 013BDC9D . 8947 1C MOV DWORD PTR DS:[EDI+0x1C],EAX&gt; 013BDCA0 . E8 23A704FF CALL 010Edito.004083C8&gt; 013BD020 /&gt; \\55 PUSH EBP&gt; 013BD021 |. 8BEC MOV EBP,ESP&gt; 013BD023 |. 8B45 08 MOV EAX,[ARG.1] &gt; ;eax=(key[1]^key[7])*100+key[2]^key[5]&gt; 013BD026 |. B9 0B000000 MOV ECX,0xB &gt; ; ecx = 0xB&gt; 013BD02B |. 35 92780000 XOR EAX,0x7892 &gt; ;eax=((key[1]^key[7])*0x100+key[2]^key[5])^0x7892&gt; 013BD030 |. 05 304D0000 ADD EAX,0x4D30&gt; ;eax=((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30&gt; 013BD035 |. 35 21340000 XOR EAX,0x3421&gt; ;eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BD03A |. 0FB7C0 MOVZX EAX,AX&gt; 013BD03D |. 99 CDQ&gt; 013BD03E |. F7F9 IDIV ECX &gt; ;eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB&gt; 013BD040 |. 85D2 TEST EDX,EDX ;eax/ecx的余数是否为0&gt; 013BD042 |. 74 02 JE SHORT 010Edito.013BD046 ;如果余数不为0,清零eax&gt; 013BD044 |. 33C0 XOR EAX,EAX&gt; 013BD046 |&gt; 5D POP EBP &gt; 013BD047 \\. C3 RETN&gt; &gt; 013BDCA5 . 8B4F 1C MOV ECX,DWORD PTR DS:[EDI+0x1C]&gt; ; ecx = (key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BDCA8 . 83C4 08 ADD ESP,0x8 &gt; 013BDCAB . 0FB7C0 MOVZX EAX,AX&gt; ;eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BDCAE . 8947 20 MOV DWORD PTR DS:[EDI+0x20],EAX&gt; ;[EDI+0x20] =(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB&gt; 013BDCB1 . 85C9 TEST ECX,ECX &gt; 013BDCB3 . 0F84 BC010000 JE 010Edito.013BDE75 ;ecx = 0 则eax=E7返回，验证失败&gt; 013BDCB9 . 85C0 TEST EAX,EAX&gt; 013BDCBB . 0F84 B4010000 JE 010Edito.013BDE75 ;eax = 0 则eax=E7返回，验证失败&gt; 013BDCC1 . 3D E8030000 CMP EAX,0x3E8&gt; 013BDCC6 . 0F87 A9010000 JA 010Edito.013BDE75 ;eax &gt; 0x3E8 则eax=E7返回，验证失败&gt; 013BDCCC . 83F9 02 CMP ECX,0x2 ;ecx小于等于1时，借位cf=1,否则cf=0&gt; 013BDCCF . 1BF6 SBB ESI,ESI ; esi=esi-esi-CF=-cf&gt; 013BDCD1 . 23F1 AND ESI,ECX ;esi = esi &amp; ecx &gt; 013BDCD3 . E9 B3000000 JMP 010Edito.013BDD8B ;0xAC分支也跳转到这里013BDD8B&gt; 当KEY[3] == 0x9C时，等换成C为 123456789101112131415161718192021222324252627282930&gt; case 0x9C:&gt; &#123;&gt; [EDI+0x1C] = (key[0]^key[6]^0x18+0x3D)^0xA7; //最后一步验证用到&gt; [EDI+0x20] =(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421;&gt; eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421;&gt; ecx = (key[0]^key[6]^0x18+0x3D)^0xA7;&gt; cf = 0;&gt; if(eax % 0xB != 0)&gt; &#123;&gt; eax = 0;&gt; &#125; &gt; if(ecx == 0 || eax == 0 || eax &gt; 0x3E8)&gt; &#123;&gt; //验证失败&gt; return;&gt; &#125;&gt; else &gt; &#123;&gt; &gt; eax=(((key[1]^key[7])*0x100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB;&gt; [EDI+0x20] = eax;&gt; if(ecx &lt;= 1)&gt; &#123;&gt; cf = 1;&gt; &#125;&gt; esi = (0 - cf) &amp; ecx; //cf=0 则 esi=0;&gt; &#125;&gt; break;&gt; &#125;&gt; 当KEY[3] == 0xFC时，所有跳转最终都不返回我们需要的0x2D ，跳过。 当KEY[3] == 0xAC时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&gt; 013BDCFC &gt; \\80FB AC CMP BL,0xAC&gt; 013BDCFF . 0F85 70010000 JNZ 010Edito.013BDE75&gt; 013BDD05 . 8A45 DD MOV AL,BYTE PTR SS:[EBP-0x23] ; al = key[1]&gt; 013BDD08 . 3245 E3 XOR AL,BYTE PTR SS:[EBP-0x1D] ; al = key[1]^key[7]&gt; 013BDD0B . 0FB6C8 MOVZX ECX,AL ; ecx = key[1]^key[7]&gt; 013BDD0E . B8 00010000 MOV EAX,0x100&gt; 013BDD13 . 66:0FAFC8 IMUL CX,AX ; cx = (key[1]^key[7]) * 0x100&gt; 013BDD17 . 8A45 DE MOV AL,BYTE PTR SS:[EBP-0x22] ; al = key[2]&gt; 013BDD1A . 32C7 XOR AL,BH ; al = key[2]^key[5]&gt; 013BDD1C . C747 1C 02000&gt;MOV DWORD PTR DS:[EDI+0x1C],0x2 ;[edi+0x1C] = 0x2&gt; 013BDD23 . 0FB6C0 MOVZX EAX,AL ; eax = key[2]^key[5]&gt; 013BDD26 . 66:03C8 ADD CX,AX ; cx = (key[1]^key[7]) * 0x100 + key[2]^key[5]&gt; 013BDD29 . 0FB7C1 MOVZX EAX,CX ; eax = (key[1]^key[7]) * 0x100 + key[2]^key[5]&gt; 013BDD2C . 50 PUSH EAX&gt; 013BDD2D . E8 96A604FF CALL 010Edito.004083C8&gt; 013BD020 /&gt; \\55 PUSH EBP&gt; 013BD021 |. 8BEC MOV EBP,ESP&gt; 013BD023 |. 8B45 08 MOV EAX,[ARG.1] &gt; 013BD026 |. B9 0B000000 MOV ECX,0xB&gt; 013BD02B |. 35 92780000 XOR EAX,0x7892 ; eax = ((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892&gt; 013BD030 |. 05 304D0000 ADD EAX,0x4D30 ; eax = ((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30&gt; 013BD035 |. 35 21340000 XOR EAX,0x3421 ; eax = (((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BD03A |. 0FB7C0 MOVZX EAX,AX&gt; 013BD03D |. 99 CDQ&gt; 013BD03E |. F7F9 IDIV ECX ; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421)/0xB&gt; 013BD040 |. 85D2 TEST EDX,EDX ; 余数edx != 0 则，eax=0&gt; 013BD042 |. 74 02 JE SHORT 010Edito.013BD046&gt; 013BD044 |. 33C0 XOR EAX,EAX&gt; 013BD046 |&gt; 5D POP EBP &gt; 013BD047 \\. C3 RETN&gt; &gt; 013BDD32 . 0FB7C0 MOVZX EAX,AX&gt; 013BDD35 . 83C4 04 ADD ESP,0x4&gt; 013BDD38 . 8947 20 MOV DWORD PTR DS:[EDI+0x20],EAX&gt; 013BDD3B . 85C0 TEST EAX,EAX ; 检测上面的函数返回结果eax是否为0&gt; 013BDD3D . 0F84 32010000 JE 010Edito.013BDE75;eax=0跳转到返回0xE7，验证失败&gt; 013BDD43 . 3D E8030000 CMP EAX,0x3E8&gt; 013BDD48 . 0F87 27010000 JA 010Edito.013BDE75;eax大于0x3E8跳转到返回0xE7，验证失败&gt; 013BDD4E . 0FB655 E5 MOVZX EDX,BYTE PTR SS:[EBP-0x1B] ; edx = key[9]&gt; 013BDD52 . 0FB64D E0 MOVZX ECX,BYTE PTR SS:[EBP-0x20] ; ecx = key[4]&gt; 013BDD56 . 0FB6C7 MOVZX EAX,BH ; eax = key[5]&gt; 013BDD59 . 33D0 XOR EDX,EAX ; edx = key[9]^key[5]&gt; 013BDD5B . 0FB645 E4 MOVZX EAX,BYTE PTR SS:[EBP-0x1C] ; eax = key[8] &gt; 013BDD5F . 33C8 XOR ECX,EAX ; ecx = key[4]^key[8]&gt; 013BDD61 . C1E2 08 SHL EDX,0x8&gt; 013BDD64 . 0FB645 E2 MOVZX EAX,BYTE PTR SS:[EBP-0x1E] ; eax = key[6]&gt; 013BDD68 . 03D1 ADD EDX,ECX ; edx = ((key[9]^key[5])&lt;&lt;8) + key[4]^key[8]&gt; 013BDD6A . 0FB64D DC MOVZX ECX,BYTE PTR SS:[EBP-0x24] ; ecx = key[0]&gt; 013BDD6E . C1E2 08 SHL EDX,0x8 ; edx = (((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8&gt; 013BDD71 . 33C8 XOR ECX,EAX ; ecx = key[0]^key[6]&gt; 013BDD73 . 03D1 ADD EDX,ECX ; edx = ((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]&gt; 013BDD75 . 68 278C5B00 PUSH 010Edito.005B8C27 ; CCCCCCCC&gt; 013BDD7A . 52 PUSH EDX&gt; 013BDD7B . E8 0BCA04FF CALL 010Edito.0040A78B&gt; 013BCF90 /&gt; \\55 PUSH EBP&gt; 013BCF91 |. 8BEC MOV EBP,ESP&gt; 013BCF93 |. 8B4D 08 MOV ECX,[ARG.1] ; ecx = ((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]&gt; 013BCF96 |. B8 F1F0F0F0 MOV EAX,0xF0F0F0F1&gt; 013BCF9B |. 334D 0C XOR ECX,[ARG.2] ; ecx = (((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27 &gt; 013BCF9E |. 81F1 78C02200 XOR ECX,0x22C078 ; ecx = ((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078&gt; 013BCFA4 |. 81E9 75C10200 SUB ECX,0x2C175 ; ecx = ((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175&gt; 013BCFAA |. 81F1 6731E5FF XOR ECX,0xFFE53167 ; ecx = (((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175) ^ 0xFFE53167&gt; 013BCFB0 |. 81E1 FFFFFF00 AND ECX,0xFFFFFF ; ecx = ((((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175) ^ 0xFFE53167) &amp; 0xFFFFFF&gt; 013BCFB6 |. F7E1 MUL ECX ; eax = 0xF0F0F0F1 * ecx 结果高32位放在edx。 低32位放在eax&gt; 013BCFB8 |. C1EA 04 SHR EDX,0x4&gt; 013BCFBB |. 8BC2 MOV EAX,EDX&gt; 013BCFBD |. C1E0 04 SHL EAX,0x4&gt; 013BCFC0 |. 03C2 ADD EAX,EDX&gt; 013BCFC2 |. 2BC8 SUB ECX,EAX ;结果为0 则 zf=1&gt; 013BCFC4 |. B8 00000000 MOV EAX,0x0&gt; 013BCFC9 |. 0F44C2 CMOVE EAX,EDX ;当zf = 1时移动 &gt; 013BCFCC |. 5D POP EBP &gt; 013BCFCD \\. C3 RETN&gt; &gt; &gt; 013BDD80 . 83C4 08 ADD ESP,0x8&gt; 013BDD83 . 8945 F0 MOV DWORD PTR SS:[EBP-0x10],EAX&gt; 013BDD86 . 8947 34 MOV DWORD PTR DS:[EDI+0x34],EAX&gt; 013BDD89 . 8BF0 MOV ESI,EAX&gt; 013BDD8B &gt; \\8D45 EC LEA EAX,DWORD PTR SS:[EBP-0x14];0x9C分支也跳转到这里&gt; 转换成C代码 123456789101112131415161718192021222324252627&gt; case 0xAC:&gt; &#123;&gt; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421);&gt; ecx = ((((((((key[9]^key[5]) &lt;&lt; 8) + key[4]^key[8]) &lt;&lt; 8) + key[0]^key[6]) ^ 0x005B8C27) ^ 0x22C078 - 0x2C175) ^ 0xFFE53167) &amp; 0xFFFFFF;&gt; if(eax % 0xB != 0)&gt; &#123;&gt; eax = 0;&gt; return ; //跳转返回0x7E分支，验证失败&gt; &#125;&gt; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421)/0xB;&gt; eax = 0xF0F0F0F1 * ecx; // 结果高32位放在edx。 低32位放在eax&gt; edx = edx &gt;&gt; 4;&gt; eax = edx;&gt; eax = eax &lt;&lt; 4;&gt; eax = eax + edx;&gt; ecx = ecx - eax;&gt; eax = 0;&gt; if（ecx==0）&gt; &#123;&gt; eax = edx; &gt; &#125; &gt; [ebp-0x10] = eax; //最后一步验证用到&gt; [edi+0x34] = eax;&gt; esi = eax;&gt; break;&gt; &#125;&gt; 分支0x9C、0xAC都将运行到此处 12345&gt;013BDD8B &gt; \\8D45 EC LEA EAX,DWORD PTR SS:[EBP-0x14]&gt;013BDD8E . 50 PUSH EAX&gt;013BDD8F . 8D4F 04 LEA ECX,DWORD PTR DS:[EDI+0x4]&gt;013BDD92 . FF15 782BE702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?toUtf8@QString@@QBE?AVQByteArr&gt;; Qt5Core.?toUtf8@QString@@QBE?AVQByteArray@@XZ&gt; 不知道这段是干嘛，我们继续单步，到如上图所示，函数[&lt;&amp;Qt5Core.?data@QByteArray@@QAE&gt;] 返回了用户名字符串，然后传入函数010Edito.00402E50，其再返回 一串类似哈希值的值，那么这个函数的作用应该为处理函数名称，进入分析。 第四步 分析用户名处理函数 根据mov esp, 0x10可知，用户名处理函数共有四个参数 参数1：用户名 参数2：当BL=0XFC时为1，否则为0，根据前面的分析可知，BL为Key[3] 参数3：esi，经上一个函数处理得到 参数4：[edi+0x20]，经上一个函数处理得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&gt; 013BD120 /&gt; \\55 PUSH EBP&gt; 013BD121 |. 8BEC MOV EBP,ESP&gt; 013BD123 |. 83EC 10 SUB ESP,0x10&gt; 013BD126 |. 8B55 08 MOV EDX,[ARG.1]&gt; ;edx = 用户名pName&gt; 013BD129 |. 33C9 XOR ECX,ECX&gt; ;ecx = 0&gt; 013BD12B |. 56 PUSH ESI&gt; ;备份esi&gt; 013BD12C |. 8BF2 MOV ESI,EDX&gt; ;esi = 用户名pName&gt; 013BD12E |. 894D FC MOV [LOCAL.1],ECX&gt; ;[LOCAL.1] = 0&gt; 013BD131 |. 57 PUSH EDI&gt; ;备份EDI&gt; 013BD132 |. 8D7E 01 LEA EDI,DWORD PTR DS:[ESI+0x1]&gt; ;edi = 用户名地址 + 1，后面被esi减去求得长度&gt; 013BD135 |&gt; 8A06 /MOV AL,BYTE PTR DS:[ESI]&gt; ;al = pName[0]&gt; 013BD137 |. 46 |INC ESI&gt; ;pName++&gt; 013BD138 |. 84C0 |TEST AL,AL&gt; 013BD13A |.^ 75 F9 \\JNZ SHORT 010Edito.013BD135&gt; ;判断是否到达字符串结尾&gt; 013BD13C |. 2BF7 SUB ESI,EDI&gt; ;求得长度，ESI指向为用户名字符串结尾的&apos;\\0&apos;&gt; 013BD13E |. 33FF XOR EDI,EDI&gt; 013BD140 |. 85F6 TEST ESI,ESI&gt; 013BD142 |. 0F8E F0000000 JLE 010Edito.013BD238&gt; ;检查长度是否不为0&gt; 013BD148 |. 53 PUSH EBX&gt; 013BD149 |. 8B5D 14 MOV EBX,[ARG.4]&gt; ;ebx = [ARG.4] = 传入的[edi+0x20]&gt; 013BD14C |. 894D F0 MOV [LOCAL.4],ECX ;置零&gt; 013BD14F |. 894D F4 MOV [LOCAL.3],ECX ;置零&gt; 013BD152 |. 8B4D 10 MOV ECX,[ARG.3]&gt; ;ecx = [ARG.3] = 传入的esi&gt; 013BD155 |. C1E3 04 SHL EBX,0x4&gt; 013BD158 |. 2B5D 14 SUB EBX,[ARG.4]&gt; ;ebx = ([ARG.4] *16) - [ARG.4]&gt; 013BD15B |. C1E1 04 SHL ECX,0x4&gt; 013BD15E |. 034D 10 ADD ECX,[ARG.3]&gt; ;ecx = ([ARG.3] *16) + [ARG.3]&gt; 013BD161 |. 894D F8 MOV [LOCAL.2],ECX&gt; ;[LOCAL.2] = ([ARG.3] &lt;&lt; 4) + [ARG.3]&gt; 013BD164 |&gt; 0FB60417 /MOVZX EAX,BYTE PTR DS:[EDI+EDX]&gt; 013BD168 |. 50 |PUSH EAX ; /c = B6&gt; 013BD169 |. FF15 9422E702 |CALL DWORD PTR DS:[&lt;&amp;MSVCR120.toupper&gt;] ; \\toupper 小写字母转换为大写字母&gt; 013BD16F |. 8BD0 |MOV EDX,EAX&gt; ;返回值复制给edx，大写字符&gt; 013BD171 |. 83C4 04 |ADD ESP,0x4&gt; 013BD174 |. 8B0C95 4841E6&gt;|MOV ECX,DWORD PTR DS:[EDX*4+0x2E64148]&gt; ;将大写字母作为索引从数组0x2E64148中取内容&gt; ;为了方便，把数组0x2E64148称为nArray，故这里ecx = nArray[edx]&gt; 013BD17B |. 034D FC |ADD ECX,[LOCAL.1]&gt; ;ecx =nArray[大写字符] + [LOCAL.1] ,[LOCAL.1]最初为0&gt; 013BD17E |. 837D 0C 00 |CMP [ARG.2],0x0&gt; ;判断是哪种类型的注册&gt; 013BD182 |. 74 4A |JE SHORT 010Edito.013BD1CE&gt; &gt; &gt; ;注册类型1---------------------------------------------------------&gt; 013BD184 |. 8D42 0D |LEA EAX,DWORD PTR DS:[EDX+0xD] &gt; 013BD187 |. 25 FF000000 |AND EAX,0xFF&gt; ;eax = [大写字符+0xD] &amp; 0xFF，这个值为数组下标，与0xFF可能说明数组最大个数为0xFF,即256个&gt; 013BD18C |. 330C85 4841E6&gt;|XOR ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = (nArray[大写字符] + [LOCAL.1]) ^ nArray[eax]&gt; 013BD193 |. 8D42 2F |LEA EAX,DWORD PTR DS:[EDX+0x2F]&gt; ;eax = [大写字符+0x2F]&gt; 013BD196 |. 25 FF000000 |AND EAX,0xFF&gt; ;eax = eax &amp; 0xFF&gt; 013BD19B |. 0FAF0C85 4841&gt;|IMUL ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx*nArray[eax]&gt; 013BD1A3 |. 8B45 F8 |MOV EAX,[LOCAL.2] ; 010Edito.01885E59&gt; ;eax = [LOCAL.2] = ([ARG.3] &lt;&lt; 4) + [ARG.3]&gt; 013BD1A6 |. 0FB6C0 |MOVZX EAX,AL&gt; ;eax &amp;= 0xFF&gt; 013BD1A9 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx + nArray[eax]&gt; 013BD1B0 |. 0FB6C3 |MOVZX EAX,BL&gt; ;eax = ebx = ([ARG.4] &lt;&lt; 4) - [ARG.4]&gt; 013BD1B3 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx + nArray[eax]&gt; 013BD1BA |. 8B45 F4 |MOV EAX,[LOCAL.3]&gt; ;eax = [LOCAL.3]&gt; 013BD1BD |. 0FB6C0 |MOVZX EAX,AL&gt; 013BD1C0 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; ;ecx = ecx + nArray[eax]&gt; 013BD1C7 |. 8BC1 |MOV EAX,ECX&gt; ;eax = ecx&gt; 013BD1C9 |. 8945 FC |MOV [LOCAL.1],EAX&gt; ;[LOCAL.1] = eax&gt; 013BD1CC |. EB 48 |JMP SHORT 010Edito.013BD216&gt; &gt; &gt; ;注册类型0----------------------------------------------------------&gt; 013BD1CE |&gt; 8D42 3F |LEA EAX,DWORD PTR DS:[EDX+0x3F];这里不同&gt; 013BD1D1 |. 25 FF000000 |AND EAX,0xFF&gt; 013BD1D6 |. 330C85 4841E6&gt;|XOR ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD1DD |. 8D42 17 |LEA EAX,DWORD PTR DS:[EDX+0x17];这里不同&gt; 013BD1E0 |. 25 FF000000 |AND EAX,0xFF&gt; 013BD1E5 |. 0FAF0C85 4841&gt;|IMUL ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD1ED |. 8B45 F8 |MOV EAX,[LOCAL.2] ; 010Edito.01885E59&gt; 013BD1F0 |. 0FB6C0 |MOVZX EAX,AL&gt; 013BD1F3 |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD1FA |. 0FB6C3 |MOVZX EAX,BL&gt; 013BD1FD |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD204 |. 8B45 F0 |MOV EAX,[LOCAL.4]&gt; ;eax = [LOCAL.4], 另一种注册类型这里为 [LOCAL.3]&gt; 013BD207 |. 0FB6C0 |MOVZX EAX,AL&gt; 013BD20A |. 030C85 4841E6&gt;|ADD ECX,DWORD PTR DS:[EAX*4+0x2E64148]&gt; 013BD211 |. 8BC1 |MOV EAX,ECX&gt; 013BD213 |. 894D FC |MOV [LOCAL.1],ECX&gt; &gt; &gt; &gt; ;共通线----------------------------------------------------------------&gt; 013BD216 |&gt; 8345 F4 13 |ADD [LOCAL.3],0x13&gt; ;[LOCAL.3] += 0x13&gt; 013BD21A |. 47 |INC EDI&gt; 013BD21B |. 8345 F8 09 |ADD [LOCAL.2],0x9&gt; ;[LOCAL.2] += 0x9&gt; 013BD21F |. 83C3 0D |ADD EBX,0xD&gt; ;EBX += 0xD&gt; 013BD222 |. 8345 F0 07 |ADD [LOCAL.4],0x7&gt; ;[LOCAL.4] += 0x7&gt; 013BD226 |. 8B55 08 |MOV EDX,[ARG.1]&gt; ; EDX = [ARG.1] = 用户名&gt; 013BD229 |. 3BFE |CMP EDI,ESI&gt; ;ESI指向为用户名字符串结尾的0， 判断EDI是否也到结尾，没有则继续循环计算&gt; 013BD22B |.^ 0F8C 33FFFFFF \\JL 010Edito.013BD164&gt; 013BD231 |. 5B POP EBX ; 05661E08&gt; 013BD232 |. 5F POP EDI ; 05661E08&gt; 013BD233 |. 5E POP ESI ; 05661E08&gt; 013BD234 |. 8BE5 MOV ESP,EBP&gt; 013BD236 |. 5D POP EBP ; 05661E08&gt; 013BD237 |. C3 RETN&gt; &gt; ;用户名长度为0------------------------------------------------------&gt; 013BD238 |&gt; 5F POP EDI ; 05661E08&gt; 013BD239 |. 8BC1 MOV EAX,ECX&gt; 013BD23B |. 5E POP ESI ; 05661E08&gt; 013BD23C |. 8BE5 MOV ESP,EBP&gt; 013BD23E |. 5D POP EBP ; 05661E08&gt; 013BD23F \\. C3 RETN&gt; 转换成C语言 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; arg_1 = pName;&gt; arg_2;&gt; arg_3 = ESI;&gt; arg_4 = [edi+0x20];&gt; &gt; DWORD LOCAL_1 = 0;&gt; DWORD LOCAL_2 = (arg_3 * 16) + arg_3&gt; DWORD LOCAL_3 = 0;&gt; DWORD LOCAL_4 = 0;&gt; &gt; ebx =(arg_4 * 16) - arg_4;&gt; char nArray[256]=&gt; &#123;&gt; 39CB44B8, 23754F67, 5F017211, 3EBB24DA, 351707C6, 63F9774B, 17827288, 0FE74821, 5B5F670F, 48315AE8, 785B7769, 2B7A1547, 38D11292, 42A11B32, 35332244, 77437B60, 1EAB3B10, 53810000, 1D0212AE, 6F0377A8, 43C03092, 2D3C0A8E, 62950CBF, 30F06FFA, 34F710E0, 28F417FB, 350D2F95, 5A361D5A, 15CC060B, 0AFD13CC, 28603BCF, 3371066B, 30CD14E4, 175D3A67, 6DD66A13, 2D3409F9, 581E7B82, 76526B99, 5C8D5188, 2C857971, 15F51FC0, 68CC0D11, 49F55E5C, 275E4364, 2D1E0DBC, 4CEE7CE3, 32555840, 112E2E08, 6978065A, 72921406, 314578E7, 175621B7, 40771DBF, 3FC238D6, 4A31128A, 2DAD036E, 41A069D6, 25400192, 00DD4667, 6AFC1F4F, 571040CE, 62FE66DF, 41DB4B3E, 3582231F, 55F6079A, 1CA70644, 1B1643D2, 3F7228C9, 5F141070, 3E1474AB, 444B256E, 537050D9, 0F42094B, 2FD820E6, 778B2E5E, 71176D02, 7FEA7A69, 5BB54628, 19BA6C71, 39763A99, 178D54CD, 01246E88, 3313537E, 2B8E2D17, 2A3D10BE, 59D10582, 37A163DB, 30D6489A, 6A215C46, 0E1C7A76, 1FC760E7, 79B80C65, 27F459B4, 799A7326, 50BA1782, 2A116D5C, 63866E1B, 3F920E3C, 55023490, 55B56089, 2C391FD1, 2F8035C2, 64FD2B7A, 4CE8759A, 518504F0, 799501A8, 3F5B2CAD, 38E60160, 637641D8, 33352A42, 51A22C19, 085C5851, 032917AB, 2B770AC7, 30AC77B3, 2BEC1907, 035202D0, 0FA933D3, 61255DF3, 22AD06BF, 58B86971, 5FCA0DE5, 700D6456, 56A973DB, 5AB759FD, 330E0BE2, 5B3C0DDD, 495D3C60, 53BD59A6, 4C5E6D91, 49D9318D, 103D5079, 61CE42E3, 7ED5121D, 14E160ED, 212D4EF2, 270133F0, 62435A96, 1FA75E8B, 6F092FBE, 4A000D49, 57AE1C70, 004E2477, 561E7E72, 468C0033, 5DCC2402, 78507AC6, 58AF24C7, 0DF62D34, 358A4708, 3CFB1E11, 2B71451C, 77A75295, 56890721, 0FEF75F3, 120F24F1, 01990AE7, 339C4452, 27A15B8E, 0BA7276D, 60DC1B7B, 4F4B7F82, 67DB7007, 4F4A57D9, 621252E8, 20532CFC, 6A390306, 18800423, 19F3778A, 462316F0, 56AE0937, 43C2675C, 65CA45FD, 0D604FF2, 0BFD22CB, 3AFE643B, 3BF67FA6, 44623579, 184031F8, 32174F97, 4C6A092A, 5FB50261, 01650174, 33634AF1, 712D18F4, 6E997169, 5DAB7AFE, 7C2B2EE8, 6EDB75B4, 5F836FB6, 3C2A6DD6, 292D05C2, 052244DB, 149A5F4F, 5D486540, 331D15EA, 4F456920, 483A699F, 3B450F05, 3B207C6C, 749D70FE, 417461F6, 62B031F1, 2750577B, 29131533, 588C3808, 1AEF3456, 0F3C00EC, 7DA74742, 4B797A6C, 5EBB3287, 786558B8, 00ED4FF2, 6269691E, 24A2255F, 62C11F7E, 2F8A7DCD, 643B17FE, 778318B8, 253B60FE, 34BB63A3, 5B03214F, 5F1571F4, 1A316E9F, 7ACF2704, 28896838, 18614677, 1BF569EB, 0BA85EC9, 6ACA6B46, 1E43422A, 514D5F0E, 413E018C, 307626E9, 01ED1DFA, 49F46F5A, 461B642B, 7D7007F2, 13652657, 6B160BC5, 65E04849, 1F526E1C, 5A0251B6, 2BD73F69, 2DBF7ACD, 51E63E80, 5CF2670F, 21CD0A03, 5CFF0261, 33AE061E, 3BB6345F, 5D814A75, 257B5DF4, 0A5C2C5B, 16A45527, 16F23945&gt; &#125;;&gt; &gt; while(nNameLen)&gt; &#123;&gt; pName[i]&gt; char cName = toupper(pName); //小写转大写&gt; &gt; //注册类型1&gt; if(key[3] != 0xFC)&gt; &#123;&gt; LOCAL_1 = (nArray[cName]+LOCAL_1);&gt; LOCAL_1 ^= nArray[(cName+0xD)];&gt; LOCAL_1 *= nArray[(cName+0x2F)];&gt; &gt; LOCAL_1 += nArray[LOCAL_2];&gt; LOCAL_1 += nArray[ebx];&gt; LOCAL_1 += nArray[LOCAL_3];&gt; &#125;&gt; //注册类型0,没有用到&gt; else if(key[3] == 0xFC)&gt; &#123;&gt; LOCAL_1 = (nArray[cName]+LOCAL_1);&gt; LOCAL_1 ^= nArray[(cName+0x3F)];&gt; LOCAL_1 *= nArray[(cName+0x17)];&gt; &gt; LOCAL_1 += nArray[LOCAL_2];&gt; LOCAL_1 += nArray[ebx];&gt; LOCAL_1 += nArray[LOCAL_4];&gt; &#125;&gt; LOCAL_3 += 0x13;&gt; nNameLen--;&gt; LOCAL_2 += 0x9;&gt; ebx += 0xD &gt; LOCAL_4 += 0x7;&gt; i++;&gt; &#125;&gt; return LOCAL_1;&gt; 函数返回结果如上图。 第五步 处理计算结果 由上图分析可知，接下来将处理用户名函数的返回值多次右移比较，根据结果分发返回值，最终跳转到我们需要的返回值0x2D。代码如下 1234567891011121314151617181920212223242526&gt;013BDDB6 . E8 955004FF CALL 010Edito.00402E50 ; 处理用户名的函数&gt;013BDDBB . 8BD0 MOV EDX,EAX&gt;013BDDBD . 83C4 10 ADD ESP,0x10 ; 意味着上面函数有四个参数&gt;013BDDC0 . 3855 E0 CMP BYTE PTR SS:[EBP-0x20],DL ; 比较key[4]，返回值低8位&gt;013BDDC3 . 0F85 81000000 JNZ 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDC9 . 8BCA MOV ECX,EDX&gt;013BDDCB . C1E9 08 SHR ECX,0x8 ; 右移0x8&gt;013BDDCE . 3AF9 CMP BH,CL ; key[5],cl&gt;013BDDD0 . 75 78 JNZ SHORT 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDD2 . 8BCA MOV ECX,EDX&gt;013BDDD4 . C1E9 10 SHR ECX,0x10 ; 右移10位&gt;013BDDD7 . 384D E2 CMP BYTE PTR SS:[EBP-0x1E],CL ; key[6]&gt;013BDDDA . 75 6E JNZ SHORT 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDDC . C1E8 18 SHR EAX,0x18 ; 右移0x18&gt;013BDDDF . 3845 E3 CMP BYTE PTR SS:[EBP-0x1D],AL ; key[7]&gt;013BDDE2 . 75 66 JNZ SHORT 010Edito.013BDE4A ; 跳转到返回0xE7，失败&gt;013BDDE4 . 80FB 9C CMP BL,0x9C ; Switch (cases 9C..FC)&gt;013BDDE7 . 75 0F JNZ SHORT 010Edito.013BDDF8&gt;013BDDE9 . 8B45 08 MOV EAX,DWORD PTR SS:[EBP+0x8] ; Case 9C of switch 013BDDE4&gt;013BDDEC . 3B47 1C CMP EAX,DWORD PTR DS:[EDI+0x1C] ; 小于等于&gt;013BDDEF . 76 52 JBE SHORT 010Edito.013BDE43 ; 跳转到返回0x2D，验证正确&gt;013BDDF1 . BE 4E000000 MOV ESI,0x4E&gt;013BDDF6 . EB 57 JMP SHORT 010Edito.013BDE4F ; 返回返回4E，验证失败&gt;013BDDF8 &gt; 80FB FC CMP BL,0xFC&gt;013BDDFB . 75 2E JNZ SHORT 010Edito.013BDE2B ; FC分支得不到正确结果，跳过&gt; 1234567891011121314151617181920212223242526&gt;013BDE2B &gt; 80FB AC CMP BL,0xAC&gt;013BDE2E . 75 1A JNZ SHORT 010Edito.013BDE4A&gt;013BDE30 . 8B45 F0 MOV EAX,DWORD PTR SS:[EBP-0x10] ; Case AC of switch 013BDDE4&gt;013BDE33 . 85C0 TEST EAX,EAX&gt;013BDE35 . 74 13 JE SHORT 010Edito.013BDE4A ; 跳转到验证错误&gt;013BDE37 . 3945 0C CMP DWORD PTR SS:[EBP+0xC],EAX&gt;013BDE3A . 76 07 JBE SHORT 010Edito.013BDE43 ; 跳转到返回0x2D,验证正确&gt;013BDE3C . BE 4E000000 MOV ESI,0x4E&gt;013BDE41 . EB 0C JMP SHORT 010Edito.013BDE4F&gt;013BDE43 &gt; BE 2D000000 MOV ESI,0x2D ; 验证正确，返回0x2D!!!!&gt;013BDE48 . EB 05 JMP SHORT 010Edito.013BDE4F&gt;013BDE4A &gt; BE E7000000 MOV ESI,0xE7 ; Default case of switch 013BDDE4&gt;013BDE4F &gt; 8D4D EC LEA ECX,DWORD PTR SS:[EBP-0x14]&gt;013BDE52 . C745 FC FFFFF&gt;MOV DWORD PTR SS:[EBP-0x4],-0x1&gt;013BDE59 . FF15 7C24E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.??1Q&gt;; Qt5Core.??1QByteArray@@QAE@XZ&gt;013BDE5F . 8BC6 MOV EAX,ESI&gt;013BDE61 . 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-0xC]&gt;013BDE64 . 64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX&gt;013BDE6B . 59 POP ECX ; 0584FD48&gt;013BDE6C . 5F POP EDI ; 0584FD48&gt;013BDE6D . 5E POP ESI ; 0584FD48&gt;013BDE6E . 5B POP EBX ; 0584FD48&gt;013BDE6F . 8BE5 MOV ESP,EBP&gt;013BDE71 . 5D POP EBP ; 0584FD48&gt;013BDE72 . C2 0800 RETN 0x8&gt; 上述代码中，将返回值低八位和key[ n ]进行比较，每次比较完后右移八位，再次比较新数值的低八位。总共比较4次，正好将32位返回值全部比对完。 在第三步分析0x9C分支中已经得到 [EDI+0x1C] = ecx = (key[0]^key[6]^0x18+0x3D)^0xA7， 局部变量 [ EBP+0x8 ] = 9。 局部变量[ EBP - 0x10] 为第三步中分析AC分支返回eax得到， 12&gt; eax = ((((key[1]^key[7]) * 0x100 + key[2]^key[5])^0x7892 + 0x4D30)^0x3421)/0xB;&gt; 局部变量 [ EBP+0xC ] = 4389。 转换为C代码为 1234567891011121314151617181920212223242526272829&gt;//将返回值看成为一个数组，nArray[4]&gt;if((nArray[0]==key[4]) &amp;&amp;&gt; (nArray[1]==key[5]) &amp;&amp;&gt; (nArray[2]==key[6]) &amp;&amp;&gt; (nArray[3]==key[7]))&gt; &#123;&gt; if(key[3]==0x9C)&gt; &#123;&gt; //[EDI+0x1C] = (key[0]^key[6]^0x18+0x3D)^0xA7;&gt; if(9 &lt;= (key[0]^key[6]^0x18+0x3D)^0xA7))&gt; &#123;&gt; return 0x2D; //验证成功&gt; &#125;&gt; return 0x4E; //验证失败&gt; &#125;&gt; else if(key[3]==0xFC)&gt; &#123;&gt; return 0xE7; //验证失败&gt; &#125;&gt; else if(key[3]=0xAC)&gt; &#123;&gt; if([ebp - 10] &gt;= 4389) &gt; &#123;&gt; return 0x2D; //验证成功&gt; &#125;&gt; return 0x4E; //验证失败&gt; &#125;&gt; &#125;&gt; 第六步 编写注册机","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://yoursite.com/tags/逆向/"}]},{"title":"DLL注入+VEH 的方式处理异常 （一）","slug":"DLL注入 + VEH 的方式处理异常","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:53:13.051Z","comments":true,"path":"2018/06/21/DLL注入 + VEH 的方式处理异常/","link":"","permalink":"http://yoursite.com/2018/06/21/DLL注入 + VEH 的方式处理异常/","excerpt":"","text":"test.cpp 12345678910111213#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; printf(\"输入\\n\"); int a, b; scanf_s(\"%d\", &amp;a); b = 1 / a; printf(\"%d\\n\", b); system(\"pause\"); return 0;&#125; dllmain.dll 1234567891011121314151617181920212223242526272829303132333435363738// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"stdafx.h\"#include \"stdio.h\"#include \"windows.h\"LONG WINAPI veh(EXCEPTION_POINTERS* pExce)&#123; if (pExce-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; pExce-&gt;ContextRecord-&gt;Eip += 3; printf(\"fdsf\\n\"); return EXCEPTION_CONTINUE_EXECUTION; &#125; return EXCEPTION_CONTINUE_SEARCH;&#125; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: //1. 将异常处理函数注册到系统 AddVectoredExceptionHandler(TRUE, veh); printf(\"注册异常处理函数成功！\\n\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 注入器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 远程注入.cpp: 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include \"windows.h\"bool injectDll(DWORD dwPid, const char* pszDllPath);int main()&#123; DWORD dwPid; char szDllPath[MAX_PATH] = &#123; \"C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\VEH_Dll\\\\Debug\\\\VEH_Dll.dll\"&#125;; printf(\"输入要注入到的进程PID：\"); scanf_s(\"%d[*]\", &amp;dwPid); injectDll(dwPid, szDllPath); return 0;&#125;bool injectDll(DWORD dwPid, const char* pszDllPath)&#123; bool bRet = false; HANDLE hProcess = 0; HANDLE hRemoteThread = 0; LPVOID pRemoteBuff = NULL; SIZE_T dwWrite = 0; DWORD dwSize = 0; //打开进程 hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,/*创建线程和写入内存权限*/ FALSE, dwPid/*进程ID*/); if (hProcess == NULL) &#123; printf(\"打开进程失败,可能由于本程序的权限太低,请以管理员身份运行再尝试\\n\"); goto _EXIT; &#125; //1. 在远程进程上开辟内存空间 pRemoteBuff = VirtualAllocEx( hProcess, NULL, 64*1024,/*大小：64Kb*/ MEM_COMMIT,/*预定并提交*/ PAGE_EXECUTE_READWRITE/*可读可写可执行的属性*/ ); if (pRemoteBuff == NULL) &#123; printf(\"在远程进程上开辟空降失败\\n\"); goto _EXIT; &#125; //2. 将DLL路径写入到新开的内存空间中 dwSize = strlen(pszDllPath) + 1; WriteProcessMemory( hProcess, pRemoteBuff,/* 要写入的地址 */ pszDllPath, /* 要写入的内容的地址*/ dwSize, /* 写入的字节数 */ &amp;dwWrite /* 输入：函数实际写入的字节数*/ ); if (dwWrite != dwSize) &#123; printf(\"写入Dll路径失败\\n\"); goto _EXIT; &#125; //3. 创建远程线程 // 远程线程创建成功后,DLL就会被加载,DLL被加载后DllMain函数 // 就会被执行,如果想要执行什么代码,就在DllMain中调用即可. hRemoteThread = CreateRemoteThread( hProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, /* 线程回调函数 */ pRemoteBuff, /* 回调函数参数 */ 0, 0); // 等待远程线程退出. // 退出了才释放远程进程的内存空间. WaitForSingleObject(hRemoteThread, -1); bRet = true;_EXIT: // 释放远程进程的内存 VirtualFreeEx(hProcess, pRemoteBuff, 0, MEM_RELEASE); // 关闭进程句柄 CloseHandle(hProcess); return bRet;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","slug":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:56:51.840Z","comments":true,"path":"2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","link":"","permalink":"http://yoursite.com/2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","excerpt":"","text":"KiTrap03： （1）处理int3异常的函数为KITrap03 （2）在开始异常处理之初，先构造TRAP_FRAME陷阱帧结构，陷阱帧是指一个结构体，用来保存系统调用、中断、异常发生时的寄存器现场，方便以后回到用户空间 / 回到中断处时，回复那些寄存器的值，继续执行 （3）注意到KiTrap03实际上调用了CommonDispatchException CommonDisPatchException： （1）判断是用户异常还是内核异常使用的是CS段寄存器的最后两位 （2）构件了一个异常记录的结构 （3）之后实际上调用了KiDispatchException来处理异常 KiDispatchException： （1）该函数用于分发异常，根据异常所产生的模式找到异常的函数 （2）如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常 （3）如果异常发生在用户模式，则函数会将异常记录、异常栈帧 和 陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常。 KiUserExceptionDispatcher： （1）函数第一个参数为异常类型，第二个参数为产生异常时的上下文记录 （2）KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"验证异常处理调用顺序","slug":"验证异常处理调用顺序","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:55:13.272Z","comments":true,"path":"2018/06/21/验证异常处理调用顺序/","link":"","permalink":"http://yoursite.com/2018/06/21/验证异常处理调用顺序/","excerpt":"","text":"验证异常处理调用顺序：VEH –&gt; SEH –&gt; VCH 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"stdafx.h\"#include &lt;windows.h&gt;LONG WINAPI vch(EXCEPTION_POINTERS* pExcept)&#123; printf(\"vch\\n\"); return EXCEPTION_CONTINUE_SERCH;&#125;LONG WINAPI veh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"veh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI seh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"seh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI ueh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"ueh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; AddVectoredContinueHandler(TRUE, vch); AddVectoreExceptionHandler(TRUE, veh); //在64位系统系下，当程序被调用时，UEH不会被调用，不被调试才会被调用 //在32位系统下，被调试时也会被调用 SetUnhandledExceptionFilter(ueh); __try&#123; *(int*)0=0; &#125; __except(seh(GetExceptionInformation()))&#123; &#125; return 0;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]}]}