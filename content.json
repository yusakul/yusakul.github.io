{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"梁言","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-21T13:10:11.000Z","updated":"2018-06-21T13:10:51.701Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-21T13:09:20.000Z","updated":"2018-06-21T13:09:54.271Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"010 Editor v8.0.1_x32分析以及注册机制作","slug":"010 Editor分析","date":"2018-06-25T01:09:57.000Z","updated":"2018-06-25T13:38:05.685Z","comments":true,"path":"2018/06/25/010 Editor分析/","link":"","permalink":"http://yoursite.com/2018/06/25/010 Editor分析/","excerpt":"","text":"环境以及工具 Window7_x32 010 Editor v8.0.1_x32 OD VS2017 第一步 找到判断注册结果的关键跳转和关键函数 使用OD打开010editor，进入到注册界面，先尝试输入随意的ID和Key，获取弹出的提示信息字符串 尝试在OD中搜索如下字符 “Invalid name or password.”，搜索结果如下 发现存在大量提示信息，我们在其中找到注册成功的提示信息，（上图红框：感谢购买010editor），双击查看反汇编窗口，见下图。 往上查看判断注册成功的关键跳转 我们发现地址为00DD5926处跳转JNZ 010Edito.00DD5A58应该为关键跳转，下方可以找到输出字符串”Password accepted. This ….”， 而其跳转地址处汇编代码为输出”Password accepted….” （010editor使用QT界面库编写 ，我们可以猜测出push字符串随后的函数应为输出字符串） 回到关键跳转00DD5926处，判断密码为正确的条件为EDI = 0xDB，而EDI的值是EAX给的，而EAX为函数010Edito.00409C9B的返回值，这个函数可能为验证Key的关键函数，而我们动态调试发现有跳转直接跳转到cmp edi,0xdb。 同样为函数010Edito.00409C9B，现在可以认为这是关键函数，此时EDI的值为0x177，为了验证此跳转为关键跳转，我们把EDI的值修改为0xDB。 之后F9运行 验证成功！接下来我们进入函数分析。 第二步 分析关键函数 函数010Edito.00409C9B，参数情况为： arg1 = 0x9 ； arg2 = 0x4389； 从下往上看，找到需要的0xDB，而跳转条件是eax = 0x2D， 为函数010Edito.0040A826的返回值。 进入函数，该函数作用为将key取出，放在在局部变量数组中，数组起始地址为ebx-24 1234567891011&gt; key[0 ] = [ebx-24]=0x12&gt; key[1 ] = [ebx-23]=0x34&gt; key[2 ] = [ebx-22]=0x56&gt; key[3 ] = [ebx-21]=0x78&gt; key[4 ] = [ebx-20]=0x90&gt; key[5 ] = [ebx-1F]=0x12&gt; key[6 ] = [ebx-1E]=0x34&gt; key[7 ] = [ebx-1D]=0x56&gt; key[8 ] = [ebx-1C]=0x78&gt; key[9 ] = [ebx-1B]=0x90&gt; 密钥数组对应如上，该处汇编代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&gt; 013BDC2D . 8BCF MOV ECX,EDI&gt; 013BDC2F . 50 PUSH EAX&gt; 013BDC30 . E8 3ABF04FF CALL 010Edito.00409B6F ;获取key存入局部变量数组[ebp-24]中&gt; 013BDC35 . BE 1446E602 MOV ESI,010Edito.02E64614&gt; 013BDC3A . 8D9B 00000000 LEA EBX,DWORD PTR DS:[EBX]&gt; 013BDC40 &gt; FF36 PUSH DWORD PTR DS:[ESI] ;010Edito.02995120&gt; 013BDC42 . 8BCB MOV ECX,EBX&gt; 013BDC44 . FF15 E82CE702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.??8QString@@QBE_NPBD@Z&gt;] ; Qt5Core.??8QString@@QBE_NPBD@Z&gt; 013BDC4A . 84C0 TEST AL,AL&gt; 013BDC4C . 0F85 23020000 JNZ 010Edito.013BDE75&gt; 013BDC52 . 83C6 04 ADD ESI,0x4&gt; 013BDC55 . 81FE 1846E602 CMP ESI,010Edito.02E64618&gt; 013BDC5B .^ 7C E3 JL SHORT 010Edito.013BDC40&gt; 013BDC5D . 8A5D DF MOV BL,BYTE PTR SS:[EBP-0x21] ; key[3]&gt; 013BDC60 . 8A7D E1 MOV BH,BYTE PTR SS:[EBP-0x1F] ; key[5]&gt; 013BDC63 . 80FB 9C CMP BL,0x9C ; 是否等于0x9c&gt; 013BDC66 . 75 70 JNZ SHORT 010Edito.013BDCD8 ; 跳转到是否等于FC&gt; 013BDC68 . 8A45 DC MOV AL,BYTE PTR SS:[EBP-0x24] ; key[0]&gt; 013BDC6B . 3245 E2 XOR AL,BYTE PTR SS:[EBP-0x1E] ; key[0]^key[6]&gt; 013BDC6E . 8845 E8 MOV BYTE PTR SS:[EBP-0x18],AL ;&gt; 013BDC71 . 8A45 DD MOV AL,BYTE PTR SS:[EBP-0x23] ; key[1]&gt; 013BDC74 . 3245 E3 XOR AL,BYTE PTR SS:[EBP-0x1D] ; key[1]^key[7]&gt; 013BDC77 . FF75 E8 PUSH DWORD PTR SS:[EBP-0x18]&gt; 013BDC7A . 0FB6C8 MOVZX ECX,AL&gt; 013BDC7D . B8 00010000 MOV EAX,0x100&gt; 013BDC82 . 66:0FAFC8 IMUL CX,AX ; (key[1]^key[7])*100&gt; 013BDC86 . 8A45 DE MOV AL,BYTE PTR SS:[EBP-0x22] ; key[2]&gt; 013BDC89 . 32C7 XOR AL,BH ; key[2]^key[5]&gt; 013BDC8B . 0FB6C0 MOVZX EAX,AL&gt; 013BDC8E . 66:03C8 ADD CX,AX ; ;cx = (key[1]^key[7])*100 + key[2]^key[5]&gt; 013BDC91 . 0FB7F1 MOVZX ESI,CX&gt; 013BDC94 . E8 AB9904FF CALL 010Edito.00407644 &gt; 013BD0B0 /&gt; \\55 PUSH EBP&gt; 013BD0B1 |. 8BEC MOV EBP,ESP&gt; 013BD0B3 |. 8B45 08 MOV EAX,[ARG.1] ; eax = key[0]^key[6] &gt; 013BD0B6 |. 34 18 XOR AL,0x18 ; al = key[0]^key[6]^0x18 &gt; 013BD0B8 |. 04 3D ADD AL,0x3D ; al = key[0]^key[6]^0x18 + 0x3D&gt; 013BD0BA |. 34 A7 XOR AL,0xA7 ; al =(key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BD0BC |. 5D POP EBP &gt; 013BD0BD \\. C3 RETN&gt; &gt; 013BDC99 . 0FB6C0 MOVZX EAX,AL&gt; 013BDC9C . 56 PUSH ESI ; esi = (key[1]^key[7])*100 + key[2]^key[5]&gt; 013BDC9D . 8947 1C MOV DWORD PTR DS:[EDI+0x1C],EAX&gt; 013BDCA0 . E8 23A704FF CALL 010Edito.004083C8&gt; 013BD020 /&gt; \\55 PUSH EBP&gt; 013BD021 |. 8BEC MOV EBP,ESP&gt; 013BD023 |. 8B45 08 MOV EAX,[ARG.1] ;eax=(key[1]^key[7])*100+key[2]^key[5]&gt; 013BD026 |. B9 0B000000 MOV ECX,0xB ; ecx = 0xB&gt; 013BD02B |. 35 92780000 XOR EAX,0x7892 &gt; ;eax=((key[1]^key[7])*100+key[2]^key[5])^0x7892&gt; 013BD030 |. 05 304D0000 ADD EAX,0x4D30&gt; ;eax=((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30&gt; 013BD035 |. 35 21340000 XOR EAX,0x3421&gt; ;eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BD03A |. 0FB7C0 MOVZX EAX,AX&gt; 013BD03D |. 99 CDQ&gt; 013BD03E |. F7F9 IDIV ECX &gt; ;eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB&gt; 013BD040 |. 85D2 TEST EDX,EDX ;ecx/eax的余数否为0&gt; 013BD042 |. 74 02 JE SHORT 010Edito.013BD046 ;如果余数不为0,清零eax&gt; 013BD044 |. 33C0 XOR EAX,EAX&gt; 013BD046 |&gt; 5D POP EBP &gt; 013BD047 \\. C3 RETN&gt; &gt; 013BDCA5 . 8B4F 1C MOV ECX,DWORD PTR DS:[EDI+0x1C]&gt; ; ecx = (key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BDCA8 . 83C4 08 ADD ESP,0x8 &gt; 013BDCAB . 0FB7C0 MOVZX EAX,AX&gt; ;eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BDCAE . 8947 20 MOV DWORD PTR DS:[EDI+0x20],EAX&gt; ;[EDI+0x20] =(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BDCB1 . 85C9 TEST ECX,ECX &gt; 013BDCB3 . 0F84 BC010000 JE 010Edito.013BDE75 ;ecx = 0 则eax=E7返回&gt; 013BDCB9 . 85C0 TEST EAX,EAX&gt; 013BDCBB . 0F84 B4010000 JE 010Edito.013BDE75 ;eax = 0 则eax=E7返回&gt; 013BDCC1 . 3D E8030000 CMP EAX,0x3E8&gt; 013BDCC6 . 0F87 A9010000 JA 010Edito.013BDE75 ;eax &gt; 0x3E8 则eax=E7返回&gt; 013BDCCC . 83F9 02 CMP ECX,0x2 ;ecx小于等于1时，借位cf=1,否则cf=0&gt; 013BDCCF . 1BF6 SBB ESI,ESI ; esi=esi-esi-CF=-cf&gt; 013BDCD1 . 23F1 AND ESI,ECX ; esi = esi &amp; ecx &gt; 013BDCD3 . E9 B3000000 JMP 010Edito.013BDD8B&gt; 013BDCD8 &gt; 80FB FC CMP BL,0xFC&gt; 013BDCDB . 75 1F JNZ SHORT 010Edito.013BDCFC ; 不等于FC，跳转到是否等于AC&gt; 013BDCDD . C747 1C FF000&gt;MOV DWORD PTR DS:[EDI+0x1C],0xFF ; Case FC of switch 013BDC63&gt; 013BDCE4 . BE FF000000 MOV ESI,0xFF&gt; 013BDCE9 . C747 20 01000&gt;MOV DWORD PTR DS:[EDI+0x20],0x1&gt; 013BDCF0 . C747 30 01000&gt;MOV DWORD PTR DS:[EDI+0x30],0x1&gt; 013BDCF7 . E9 8F000000 JMP 010Edito.013BDD8B&gt; 013BDCFC &gt; 80FB AC CMP BL,0xAC&gt; 013BDCFF . 0F85 70010000 JNZ 010Edito.013BDE75&gt; 013BDD05 . 8A45 DD MOV AL,BYTE PTR SS:[EBP-0x23] ; Case AC of switch 013BDC63&gt; 013BDD08 . 3245 E3 XOR AL,BYTE PTR SS:[EBP-0x1D]&gt; 013BDD0B . 0FB6C8 MOVZX ECX,AL&gt; 013BDD0E . B8 00010000 MOV EAX,0x100&gt; 013BDD13 . 66:0FAFC8 IMUL CX,AX&gt; 013BDD17 . 8A45 DE MOV AL,BYTE PTR SS:[EBP-0x22]&gt; 013BDD1A . 32C7 XOR AL,BH&gt; 013BDD1C . C747 1C 02000&gt;MOV DWORD PTR DS:[EDI+0x1C],0x2&gt; 013BDD23 . 0FB6C0 MOVZX EAX,AL&gt; 013BDD26 . 66:03C8 ADD CX,AX&gt; 013BDD29 . 0FB7C1 MOVZX EAX,CX&gt; 013BDD2C . 50 PUSH EAX&gt; 013BDD2D . E8 96A604FF CALL 010Edito.004083C8&gt; 013BDD32 . 0FB7C0 MOVZX EAX,AX&gt; 013BDD35 . 83C4 04 ADD ESP,0x4&gt; 013BDD38 . 8947 20 MOV DWORD PTR DS:[EDI+0x20],EAX&gt; 013BDD3B . 85C0 TEST EAX,EAX&gt; 013BDD3D . 0F84 32010000 JE 010Edito.013BDE75&gt; 013BDD43 . 3D E8030000 CMP EAX,0x3E8&gt; 013BDD48 . 0F87 27010000 JA 010Edito.013BDE75&gt; 013BDD4E . 0FB655 E5 MOVZX EDX,BYTE PTR SS:[EBP-0x1B]&gt; 013BDD52 . 0FB64D E0 MOVZX ECX,BYTE PTR SS:[EBP-0x20]&gt; 013BDD56 . 0FB6C7 MOVZX EAX,BH&gt; 013BDD59 . 33D0 XOR EDX,EAX&gt; 013BDD5B . 0FB645 E4 MOVZX EAX,BYTE PTR SS:[EBP-0x1C]&gt; 013BDD5F . 33C8 XOR ECX,EAX&gt; 013BDD61 . C1E2 08 SHL EDX,0x8&gt; 013BDD64 . 0FB645 E2 MOVZX EAX,BYTE PTR SS:[EBP-0x1E]&gt; 013BDD68 . 03D1 ADD EDX,ECX&gt; 013BDD6A . 0FB64D DC MOVZX ECX,BYTE PTR SS:[EBP-0x24]&gt; 013BDD6E . C1E2 08 SHL EDX,0x8&gt; 013BDD71 . 33C8 XOR ECX,EAX&gt; 013BDD73 . 03D1 ADD EDX,ECX&gt; 013BDD75 . 68 278C5B00 PUSH 010Edito.005B8C27 ; &gt; 013BDD7A . 52 PUSH EDX&gt; 013BDD7B . E8 0BCA04FF CALL 010Edito.0040A78B&gt; 013BDD80 . 83C4 08 ADD ESP,0x8&gt; 013BDD83 . 8945 F0 MOV DWORD PTR SS:[EBP-0x10],EAX&gt; 013BDD86 . 8947 34 MOV DWORD PTR DS:[EDI+0x34],EAX&gt; 013BDD89 . 8BF0 MOV ESI,EAX&gt; 013BDD8B &gt; 8D45 EC LEA EAX,DWORD PTR SS:[EBP-0x14]&gt; 013BDD8E . 50 PUSH EAX&gt; 013BDD8F . 8D4F 04 LEA ECX,DWORD PTR DS:[EDI+0x4]&gt; 013BDD92 . FF15 782BE702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?toUtf8@QString@@QBE?AVQB&gt;; Qt5Core.?toUtf8@QString@@QBE?AVQByteArray@@XZ&gt; 013BDD98 . FF77 20 PUSH DWORD PTR DS:[EDI+0x20]&gt; 013BDD9B . 33C0 XOR EAX,EAX&gt; 013BDD9D . C745 FC 00000&gt;MOV DWORD PTR SS:[EBP-0x4],0x0&gt; 013BDDA4 . 80FB FC CMP BL,0xFC&gt; 013BDDA7 . 8D4D EC LEA ECX,DWORD PTR SS:[EBP-0x14]&gt; 013BDDAA . 56 PUSH ESI ; 010Edito.02E64614&gt; 013BDDAB . 0F95C0 SETNE AL&gt; 013BDDAE . 50 PUSH EAX&gt; 013BDDAF . FF15 8C24E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?data@QByteArray@@QAEPADX&gt;; Qt5Core.?data@QByteArray@@QAEPADXZ&gt; 013BDDB5 . 50 PUSH EAX&gt; 013BDDB6 . E8 955004FF CALL 010Edito.00402E50&gt; 013BDDBB . 8BD0 MOV EDX,EAX&gt; 013BDDBD . 83C4 10 ADD ESP,0x10&gt; 013BDDC0 . 3855 E0 CMP BYTE PTR SS:[EBP-0x20],DL&gt; 013BDDC3 . 0F85 81000000 JNZ 010Edito.013BDE4A&gt; 013BDDC9 . 8BCA MOV ECX,EDX&gt; 013BDDCB . C1E9 08 SHR ECX,0x8&gt; 013BDDCE . 3AF9 CMP BH,CL&gt; 013BDDD0 . 75 78 JNZ SHORT 010Edito.013BDE4A&gt; 013BDDD2 . 8BCA MOV ECX,EDX&gt; 013BDDD4 . C1E9 10 SHR ECX,0x10&gt; 013BDDD7 . 384D E2 CMP BYTE PTR SS:[EBP-0x1E],CL&gt; 013BDDDA . 75 6E JNZ SHORT 010Edito.013BDE4A&gt; 013BDDDC . C1E8 18 SHR EAX,0x18&gt; 013BDDDF . 3845 E3 CMP BYTE PTR SS:[EBP-0x1D],AL&gt; 013BDDE2 . 75 66 JNZ SHORT 010Edito.013BDE4A&gt; 013BDDE4 . 80FB 9C CMP BL,0x9C ; Switch (cases 9C..FC)&gt; 013BDDE7 . 75 0F JNZ SHORT 010Edito.013BDDF8&gt; 013BDDE9 . 8B45 08 MOV EAX,DWORD PTR SS:[EBP+0x8] ; Case 9C of switch 013BDDE4&gt; 013BDDEC . 3B47 1C CMP EAX,DWORD PTR DS:[EDI+0x1C]&gt; 013BDDEF . 76 52 JBE SHORT 010Edito.013BDE43&gt; 013BDDF1 . BE 4E000000 MOV ESI,0x4E&gt; 013BDDF6 . EB 57 JMP SHORT 010Edito.013BDE4F&gt; 013BDDF8 &gt; 80FB FC CMP BL,0xFC&gt; 013BDDFB . 75 2E JNZ SHORT 010Edito.013BDE2B&gt; 013BDDFD . 0FB64D DE MOVZX ECX,BYTE PTR SS:[EBP-0x22] ; Case FC of switch 013BDDE4&gt; 013BDE01 . 0FB645 DD MOVZX EAX,BYTE PTR SS:[EBP-0x23]&gt; 013BDE05 . C1E1 08 SHL ECX,0x8&gt; 013BDE08 . 03C8 ADD ECX,EAX&gt; 013BDE0A . 0FB645 DC MOVZX EAX,BYTE PTR SS:[EBP-0x24]&gt; 013BDE0E . C1E1 08 SHL ECX,0x8&gt; 013BDE11 . 52 PUSH EDX&gt; 013BDE12 . 03C8 ADD ECX,EAX&gt; 013BDE14 . 51 PUSH ECX&gt; 013BDE15 . E8 71C904FF CALL 010Edito.0040A78B&gt; 013BDE1A . 83C4 08 ADD ESP,0x8&gt; 013BDE1D . 85C0 TEST EAX,EAX&gt; 013BDE1F . 74 29 JE SHORT 010Edito.013BDE4A&gt; 013BDE21 . 8947 18 MOV DWORD PTR DS:[EDI+0x18],EAX&gt; 013BDE24 . BE 93000000 MOV ESI,0x93&gt; 013BDE29 . EB 24 JMP SHORT 010Edito.013BDE4F&gt; 013BDE2B &gt; 80FB AC CMP BL,0xAC&gt; 013BDE2E . 75 1A JNZ SHORT 010Edito.013BDE4A&gt; 013BDE30 . 8B45 F0 MOV EAX,DWORD PTR SS:[EBP-0x10] ; Case AC of switch 013BDDE4&gt; 013BDE33 . 85C0 TEST EAX,EAX&gt; 013BDE35 . 74 13 JE SHORT 010Edito.013BDE4A&gt; 013BDE37 . 3945 0C CMP DWORD PTR SS:[EBP+0xC],EAX&gt; 013BDE3A . 76 07 JBE SHORT 010Edito.013BDE43&gt; 013BDE3C . BE 4E000000 MOV ESI,0x4E&gt; 013BDE41 . EB 0C JMP SHORT 010Edito.013BDE4F&gt; 013BDE43 &gt; BE 2D000000 MOV ESI,0x2D&gt; 013BDE48 . EB 05 JMP SHORT 010Edito.013BDE4F&gt; 013BDE4A &gt; BE E7000000 MOV ESI,0xE7 ; Default case of switch 013BDDE4&gt; 013BDE4F &gt; 8D4D EC LEA ECX,DWORD PTR SS:[EBP-0x14]&gt; 013BDE52 . C745 FC FFFFF&gt;MOV DWORD PTR SS:[EBP-0x4],-0x1&gt; 013BDE59 . FF15 7C24E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.??1QByteArray@@QAE@XZ&gt;] ; Qt5Core.??1QByteArray@@QAE@XZ&gt; 013BDE5F . 8BC6 MOV EAX,ESI ; 010Edito.02E64614&gt; 013BDE61 . 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-0xC]&gt; 013BDE64 . 64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX&gt; 013BDE6B . 59 POP ECX&gt; 013BDE6C . 5F POP EDI&gt; 013BDE6D . 5E POP ESI ; 010Edito.02E64614&gt; 013BDE6E . 5B POP EBX&gt; 013BDE6F . 8BE5 MOV ESP,EBP&gt; 013BDE71 . 5D POP EBP&gt; 013BDE72 . C2 0800 RETN 0x8&gt; 013BDE75 &gt; B8 E7000000 MOV EAX,0xE7 ; Default case of switch 013BDC63&gt; 013BDE7A . 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-0xC]&gt; 013BDE7D . 64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX&gt; 013BDE84 . 59 POP ECX&gt; 013BDE85 . 5F POP EDI&gt; 013BDE86 . 5E POP ESI ; 010Edito.02E64614&gt; 013BDE87 . 5B POP EBX&gt; 013BDE88 . 8BE5 MOV ESP,EBP&gt; 013BDE8A . 5D POP EBP&gt; 013BDE8B . C2 0800 RETN 0x8&gt; 013BDE8E &gt; B8 93000000 MOV EAX,0x93&gt; 013BDE93 . 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-0xC]&gt; 013BDE96 . 64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX&gt; 013BDE9D . 59 POP ECX&gt; 013BDE9E . 5F POP EDI&gt; 013BDE9F . 5E POP ESI ; 010Edito.02E64614&gt; 013BDEA0 . 5B POP EBX&gt; 013BDEA1 . 8BE5 MOV ESP,EBP&gt; 013BDEA3 . 5D POP EBP&gt; 013BDEA4 . C2 0800 RETN 0x8&gt; &gt; &gt;","categories":[],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"http://yoursite.com/tags/逆向工程/"}]},{"title":"Android游戏分析","slug":"Android游戏分析","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-23T05:59:22.201Z","comments":true,"path":"2018/06/21/Android游戏分析/","link":"","permalink":"http://yoursite.com/2018/06/21/Android游戏分析/","excerpt":"","text":"","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"DLL注入+VEH 的方式处理异常 （一）","slug":"DLL注入 + VEH 的方式处理异常","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:53:13.051Z","comments":true,"path":"2018/06/21/DLL注入 + VEH 的方式处理异常/","link":"","permalink":"http://yoursite.com/2018/06/21/DLL注入 + VEH 的方式处理异常/","excerpt":"","text":"test.cpp 12345678910111213#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; printf(\"输入\\n\"); int a, b; scanf_s(\"%d\", &amp;a); b = 1 / a; printf(\"%d\\n\", b); system(\"pause\"); return 0;&#125; dllmain.dll 1234567891011121314151617181920212223242526272829303132333435363738// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"stdafx.h\"#include \"stdio.h\"#include \"windows.h\"LONG WINAPI veh(EXCEPTION_POINTERS* pExce)&#123; if (pExce-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; pExce-&gt;ContextRecord-&gt;Eip += 3; printf(\"fdsf\\n\"); return EXCEPTION_CONTINUE_EXECUTION; &#125; return EXCEPTION_CONTINUE_SEARCH;&#125; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: //1. 将异常处理函数注册到系统 AddVectoredExceptionHandler(TRUE, veh); printf(\"注册异常处理函数成功！\\n\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 注入器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 远程注入.cpp: 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include \"windows.h\"bool injectDll(DWORD dwPid, const char* pszDllPath);int main()&#123; DWORD dwPid; char szDllPath[MAX_PATH] = &#123; \"C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\VEH_Dll\\\\Debug\\\\VEH_Dll.dll\"&#125;; printf(\"输入要注入到的进程PID：\"); scanf_s(\"%d[*]\", &amp;dwPid); injectDll(dwPid, szDllPath); return 0;&#125;bool injectDll(DWORD dwPid, const char* pszDllPath)&#123; bool bRet = false; HANDLE hProcess = 0; HANDLE hRemoteThread = 0; LPVOID pRemoteBuff = NULL; SIZE_T dwWrite = 0; DWORD dwSize = 0; //打开进程 hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,/*创建线程和写入内存权限*/ FALSE, dwPid/*进程ID*/); if (hProcess == NULL) &#123; printf(\"打开进程失败,可能由于本程序的权限太低,请以管理员身份运行再尝试\\n\"); goto _EXIT; &#125; //1. 在远程进程上开辟内存空间 pRemoteBuff = VirtualAllocEx( hProcess, NULL, 64*1024,/*大小：64Kb*/ MEM_COMMIT,/*预定并提交*/ PAGE_EXECUTE_READWRITE/*可读可写可执行的属性*/ ); if (pRemoteBuff == NULL) &#123; printf(\"在远程进程上开辟空降失败\\n\"); goto _EXIT; &#125; //2. 将DLL路径写入到新开的内存空间中 dwSize = strlen(pszDllPath) + 1; WriteProcessMemory( hProcess, pRemoteBuff,/* 要写入的地址 */ pszDllPath, /* 要写入的内容的地址*/ dwSize, /* 写入的字节数 */ &amp;dwWrite /* 输入：函数实际写入的字节数*/ ); if (dwWrite != dwSize) &#123; printf(\"写入Dll路径失败\\n\"); goto _EXIT; &#125; //3. 创建远程线程 // 远程线程创建成功后,DLL就会被加载,DLL被加载后DllMain函数 // 就会被执行,如果想要执行什么代码,就在DllMain中调用即可. hRemoteThread = CreateRemoteThread( hProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, /* 线程回调函数 */ pRemoteBuff, /* 回调函数参数 */ 0, 0); // 等待远程线程退出. // 退出了才释放远程进程的内存空间. WaitForSingleObject(hRemoteThread, -1); bRet = true;_EXIT: // 释放远程进程的内存 VirtualFreeEx(hProcess, pRemoteBuff, 0, MEM_RELEASE); // 关闭进程句柄 CloseHandle(hProcess); return bRet;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"验证异常处理调用顺序","slug":"验证异常处理调用顺序","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:55:13.272Z","comments":true,"path":"2018/06/21/验证异常处理调用顺序/","link":"","permalink":"http://yoursite.com/2018/06/21/验证异常处理调用顺序/","excerpt":"","text":"验证异常处理调用顺序：VEH –&gt; SEH –&gt; VCH 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"stdafx.h\"#include &lt;windows.h&gt;LONG WINAPI vch(EXCEPTION_POINTERS* pExcept)&#123; printf(\"vch\\n\"); return EXCEPTION_CONTINUE_SERCH;&#125;LONG WINAPI veh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"veh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI seh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"seh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI ueh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"ueh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; AddVectoredContinueHandler(TRUE, vch); AddVectoreExceptionHandler(TRUE, veh); //在64位系统系下，当程序被调用时，UEH不会被调用，不被调试才会被调用 //在32位系统下，被调试时也会被调用 SetUnhandledExceptionFilter(ueh); __try&#123; *(int*)0=0; &#125; __except(seh(GetExceptionInformation()))&#123; &#125; return 0;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","slug":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:56:51.840Z","comments":true,"path":"2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","link":"","permalink":"http://yoursite.com/2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","excerpt":"","text":"KiTrap03： （1）处理int3异常的函数为KITrap03 （2）在开始异常处理之初，先构造TRAP_FRAME陷阱帧结构，陷阱帧是指一个结构体，用来保存系统调用、中断、异常发生时的寄存器现场，方便以后回到用户空间 / 回到中断处时，回复那些寄存器的值，继续执行 （3）注意到KiTrap03实际上调用了CommonDispatchException CommonDisPatchException： （1）判断是用户异常还是内核异常使用的是CS段寄存器的最后两位 （2）构件了一个异常记录的结构 （3）之后实际上调用了KiDispatchException来处理异常 KiDispatchException： （1）该函数用于分发异常，根据异常所产生的模式找到异常的函数 （2）如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常 （3）如果异常发生在用户模式，则函数会将异常记录、异常栈帧 和 陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常。 KiUserExceptionDispatcher： （1）函数第一个参数为异常类型，第二个参数为产生异常时的上下文记录 （2）KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]}]}