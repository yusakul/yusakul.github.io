{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"梁言","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-21T13:10:11.000Z","updated":"2018-06-21T13:10:51.701Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-21T13:09:20.000Z","updated":"2018-06-21T13:09:54.271Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"调试与异常 （一）","slug":"调试与异常 （一）","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-21T13:25:52.414Z","comments":true,"path":"2018/06/21/调试与异常 （一）/","link":"","permalink":"http://yoursite.com/2018/06/21/调试与异常 （一）/","excerpt":"","text":"调试与异常 （一）一、概念 什么是IDT？ 中断描述符表（IDT），当中断和异常发生时，CPU通过查找IDT表来定位处理例程的地址，然后转去执行该处例程。 异常分发有几轮？ 内核态异常的分发过程 对于第一轮异常KiDispatchException会试图先通知内核调试器来处理异常，如果没有处理异常，那么会调用RtlDispatchExcption，试图寻找已经注册的结构化异常处理器（SEH）。 如果也没有找到，那么就会给内核调试器第二次处理的机会。仍然返回FLASE的话，就会调用KeBugCheckEx触发蓝屏。 用户态异常的分发过程 首先，KiDispatchException会判断是否发送给内核调试器，但内核调试器通常不处理用户态异常，所以KiDispatchException会试图发送给用户态调试器，方法是调用DbgkForwardException。如果不成功，KiDispatchException下一步动作是试图寻找异常处理块来处理该异常，因为用户异常发生在用户态代码中，异常处理块也是在用户态代码中。所以需要转到用户态去执行。（这也就是相对于内核态异常的分发过程，用户态异常的分发过程会麻烦一点的原因，具体方式不再累赘，参考《软件调试》）如果最终也返回FALSE，那么就会分发第二轮。 产生了异常，是先发送给调试器处理，还是先被程序的异常处理机制处理掉？ 先发送给调试器 二、编程 使用DLL注入 + VEH 的方式，处理异常程序的异常 test.cpp 12345678910111213#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; printf(\"输入\\n\"); int a, b; scanf_s(\"%d\", &amp;a); b = 1 / a; printf(\"%d\\n\", b); system(\"pause\"); return 0;&#125; dllmain.dll 1234567891011121314151617181920212223242526272829303132333435363738// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"stdafx.h\"#include \"stdio.h\"#include \"windows.h\"LONG WINAPI veh(EXCEPTION_POINTERS* pExce)&#123; if (pExce-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; pExce-&gt;ContextRecord-&gt;Eip += 3; printf(\"fdsf\\n\"); return EXCEPTION_CONTINUE_EXECUTION; &#125; return EXCEPTION_CONTINUE_SEARCH;&#125; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: //1. 将异常处理函数注册到系统 AddVectoredExceptionHandler(TRUE, veh); printf(\"注册异常处理函数成功！\\n\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 注入器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 远程注入.cpp: 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include \"windows.h\"bool injectDll(DWORD dwPid, const char* pszDllPath);int main()&#123; DWORD dwPid; char szDllPath[MAX_PATH] = &#123; \"C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\VEH_Dll\\\\Debug\\\\VEH_Dll.dll\"&#125;; printf(\"输入要注入到的进程PID：\"); scanf_s(\"%d[*]\", &amp;dwPid); injectDll(dwPid, szDllPath); return 0;&#125;bool injectDll(DWORD dwPid, const char* pszDllPath)&#123; bool bRet = false; HANDLE hProcess = 0; HANDLE hRemoteThread = 0; LPVOID pRemoteBuff = NULL; SIZE_T dwWrite = 0; DWORD dwSize = 0; //打开进程 hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,/*创建线程和写入内存权限*/ FALSE, dwPid/*进程ID*/); if (hProcess == NULL) &#123; printf(\"打开进程失败,可能由于本程序的权限太低,请以管理员身份运行再尝试\\n\"); goto _EXIT; &#125; //1. 在远程进程上开辟内存空间 pRemoteBuff = VirtualAllocEx( hProcess, NULL, 64*1024,/*大小：64Kb*/ MEM_COMMIT,/*预定并提交*/ PAGE_EXECUTE_READWRITE/*可读可写可执行的属性*/ ); if (pRemoteBuff == NULL) &#123; printf(\"在远程进程上开辟空降失败\\n\"); goto _EXIT; &#125; //2. 将DLL路径写入到新开的内存空间中 dwSize = strlen(pszDllPath) + 1; WriteProcessMemory( hProcess, pRemoteBuff,/* 要写入的地址 */ pszDllPath, /* 要写入的内容的地址*/ dwSize, /* 写入的字节数 */ &amp;dwWrite /* 输入：函数实际写入的字节数*/ ); if (dwWrite != dwSize) &#123; printf(\"写入Dll路径失败\\n\"); goto _EXIT; &#125; //3. 创建远程线程 // 远程线程创建成功后,DLL就会被加载,DLL被加载后DllMain函数 // 就会被执行,如果想要执行什么代码,就在DllMain中调用即可. hRemoteThread = CreateRemoteThread( hProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, /* 线程回调函数 */ pRemoteBuff, /* 回调函数参数 */ 0, 0); // 等待远程线程退出. // 退出了才释放远程进程的内存空间. WaitForSingleObject(hRemoteThread, -1); bRet = true;_EXIT: // 释放远程进程的内存 VirtualFreeEx(hProcess, pRemoteBuff, 0, MEM_RELEASE); // 关闭进程句柄 CloseHandle(hProcess); return bRet;&#125; 验证异常处理调用顺序：VEH –&gt; SEH –&gt; VCH 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"stdafx.h\"#include &lt;windows.h&gt;LONG WINAPI vch(EXCEPTION_POINTERS* pExcept)&#123; printf(\"vch\\n\"); return EXCEPTION_CONTINUE_SERCH;&#125;LONG WINAPI veh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"veh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI seh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"seh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI ueh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"ueh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; AddVectoredContinueHandler(TRUE, vch); AddVectoreExceptionHandler(TRUE, veh); //在64位系统系下，当程序被调用时，UEH不会被调用，不被调试才会被调用 //在32位系统下，被调试时也会被调用 SetUnhandledExceptionFilter(ueh); __try&#123; *(int*)0=0; &#125; __except(seh(GetExceptionInformation()))&#123; &#125; return 0;&#125; 分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher。 KiTrap03： （1）处理int3异常的函数为KITrap03 （2）在开始异常处理之初，先构造TRAP_FRAME陷阱帧结构，陷阱帧是指一个结构体，用来保存系统调用、中断、异常发生时的寄存器现场，方便以后回到用户空间 / 回到中断处时，回复那些寄存器的值，继续执行 （3）注意到KiTrap03实际上调用了CommonDispatchException CommonDisPatchException： （1）判断是用户异常还是内核异常使用的是CS段寄存器的最后两位 （2）构件了一个异常记录的结构 （3）之后实际上调用了KiDispatchException来处理异常 KiDispatchException： （1）该函数用于分发异常，根据异常所产生的模式找到异常的函数 （2）如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常 （3）如果异常发生在用户模式，则函数会将异常记录、异常栈帧 和 陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常。 KiUserExceptionDispatcher： （1）函数第一个参数为异常类型，第二个参数为产生异常时的上下文记录 （2）KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。","categories":[],"tags":[]},{"title":"","slug":"调试与异常 （二）","date":"2018-06-21T08:53:11.546Z","updated":"2018-06-21T08:59:25.704Z","comments":true,"path":"2018/06/21/调试与异常 （二）/","link":"","permalink":"http://yoursite.com/2018/06/21/调试与异常 （二）/","excerpt":"","text":"调试与异常 （二）概念 反调试的目的是什么？ 阻拦逆向工作者分析自己的代码 什么是静态反调试？什么是动态反调试？分别都有那些？ 静态的只要在开始破解一次就可解除全部反调试限制。 PEB（进程环境块） 12345&gt; mov eax, dword ptr FS:[0x30] //直接获取PEB的地址，&gt; 或者&gt; mov eax, dword ptr Fs:[0x18] //TEB的起始地址&gt; mov eax , dword ptr ds:[eax+30] //PEB的地址&gt; BeingDebugged(0x2)：调试标记位 调试状态下，PEB.BeingDebugged 成员（0x2）的值设置为1。非调试状态下，其值设置为0.IsDebuggerPresent() API 来获取PEB.BeingDebugged的值来判断进程是否处于被调试状态。 破解之法： 借助ollydbg调试器的编辑功能，将PEB.BeingDebugged的值修改为0即可 ldr(0xc)：内存状态 调试进程时，堆内存中会出现一些特殊标识，表示正处于被调试状态，其中最醒目的就是未使用的堆内存区域全部填充着0xFEEEFEEE。根据这一原理，我们可以判断进程是否处于调试状态。根据相应的偏移位置找到PEB.ldr位置，查找0xFEEEFEEE， 破解之法： 将填充着0xFEEEFEEE的区域全部覆盖为NULL即可注意：该方法只适用windows xp系统，在vista 之后的系统则无法使用。另外，利用附加进程将运行中的进程附加到调试器，堆内存也不会出现上述标识。 Process Heap（0x18）：堆状态 PEB.ProcessHeap成员是指向HEAD结构体的指针。其中比较重要的是Flags(+0xC)成员和Force Flags(+0x10). 1234&gt; &gt; mov eax, dword ptr fs:[0x18] //TEB的起始地址&gt; &gt; mov eax , dword ptr ds:[eax+30] //PEB的地址&gt; &gt; mov eax , dword ptr ds:[eax+18] //PEB.Processheap的地址。&gt; &gt; 进程正常运行时，heap.flags的值为0x2.heap.Forceflags的值为0x0.。进程被调试时这些值都会改变。所以比较这些值就可以判断进程是否被调试。 破解之法： 将heap.flags的值修改为0x2. heap.Forceflags的值修改为0x0。注意：该方法只适用windows xp系统，在win7之后的系统则无法使用。另外，利用附加进程将运行中的进程附加到调试器，堆内存也不会出现上述标识。 NtGlobalFlag(0x68)：全局标记 调试进程时，PEB.NtGlobalFlag成员的值会被设置为0x70.所以检测该成员的值即可判断是否处于被调试状态。NtGlobalFlag 0x70是flags值进行位或运算的结果。被调试进程的堆内存中存在特殊标识，所以在成员中添加了上述标识。 破解之法： 将PEB.NtGlobalFlag的值设为0即可。 使用原始API NtqueryInformationProcess() 通过NtqueryInformationProcess API可以获取各种与进程调试相关的信息。函数定义中有几个重要的成员: ProcessDebugPort(0x7)：获取调试端口 ProcessDebugObjectHandle(0x1E)：获取调试句柄 ProcessDebugFlags(0x1F)：获取调试标记 破解 使用CheckRemoteDebuggerPresent() API,可以查看是否调用NtqueryInformationProcess()。 ProcessDebugPort(0x7)：获取调试端口 进程处于调试状态，系统会为它分配一个调试端口，ProcessInformationClass参数的值为ProcessDebugPort（0 x7）, 若程序处于非调试状态，则变量dwDebugPort的值设置为0，若进程处于调试状态，则值设置为0xFFFFFFF. ProcessDebugObjectHandle(0x1E)：获取调试句柄 调试进程时会生成调试对象，函数的第二个参数值为ProcessDebugObjectHandle，调用参数后就能获取调试对象句柄，进程处于调试状态时，调试对象句柄的值就存在，若进程处于非调试状态，则调试对象句柄值为NULL. ProcessDebugFlags(0x1F)：获取调试标记 检测debug flag调试标志的值也可以判断是否处于被调试状态，函数 的第二个参数设置为processdebugflag(0x1)时，调用函数后通过第三个参数即可获的调试标志的值，若为0，则进程处于被调试状态，若为1，则进程处于非调试状态。 NtquerySystemInformation() ntdll!NtquerySystemInformation（）API是一个系统函数，用来获取当前运行的多种OS信息。 向SystemInformationclass参数传入Systemkerneldebuggerinformation的值（0X23）即可判断出当前系统是否处于调试模式下进行。当API返回时，若系统处在调试模式下，第二个参数的值设置为1，破解之法： windows xp系统中编辑boot.ini文件，删除 “/debugport=com1 /baudrate=115200 /Debug”值。 windows 7系统的命令窗口执行bsdedit/debug off 命令即可。并且若重启系统则要以正常模式启动。 NTQueryObject() 系统中的某个调试器调试进程时，会创建一个调试对象类型的内核对象。检测该对象是否存在课判断是否有进程正在被调试。 ntdll!NtqueryObject()API用来获取各种内核对象的信息 破解之法：钩取API ZwSetInformationThread() 强制分离被调试者和调试器的技术。利用ZwSetInformationThread()API可将被调试者和调试器分离出来。 该函数是一个原生API,用来为线程设置信息的，有两个参数，一是用来接收线程的句柄，二是表示线程信息类型，若其值设置为threadhideformdebugger(0x11),调用该函数后，调试进程就会被分离出来。 破解之法： 把threadhideformdebugger(0x11)的值修改为0后继续运行即可。当然也可以钩取相应的API. 提示：其工作原理是将线程隐藏起来，调试器就接收不到信息，从而无法调试。而且，windows Xp之后新增了DebugActiveProcessstop（)API. TLS回调函数 ETC 很多反调试技术是借助win32API获取系统信息来实现。检测ollydbg窗口 findWindow()检测ollydbg进程 createToolhelp32snapshot（）检测计算机名称是否为“Test”，“analysis”,等 getcomputername()检测程序运行路径中是否存在“test”,”sample”.等名称 getcomandline()检测虚拟机是否处于运行状态，虚拟机特有的进程名称 vmwareservice.exe vmwareTray.exe vmwareUser.exe 攻击调试器 NtSetInformationThread() ThreadHideFormDebugger(0x11) 打开进程检查 SeDebugPrivilege：检查进程是否具有调试权限 实验 SHE反调试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// SEH_AntiDebug_Native.cpp : 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include &lt;windows.h&gt;#pragma warning(disable: 4733) // 忽略“内联 asm 分配到FS:0”错误void (*g_funExceptionReturn)() = nullptr;void RightFun()&#123; MessageBox(0,L\"正常运行！\",L\"SEH反调试测试\",MB_OK); // 删除异常处理器 // 运行至此处时栈顶的信息是EXCEPTION_REGISTRATION_RECORD，里面 // 保存着其最初运行的已成处理器，我们将其保存到FS:[0]处后就相当于 // 摘除了前面注册的SEH异常链信息。 __asm pop dword ptr fs:[0]; g_funExceptionReturn();&#125;void WrongFun()&#123; MessageBox(0,L\"检测到调试器！\",L\"SEH反调试测试\",MB_OK); // 删除异常处理器 // 运行至此处时栈顶的信息是EXCEPTION_REGISTRATION_RECORD，里面 // 保存着其最初运行的已成处理器，我们将其保存到FS:[0]处后就相当于 // 摘除了前面注册的SEH异常链信息。 __asm pop dword ptr fs:[0];&#125;EXCEPTION_DISPOSITION ExpHandel_A( EXCEPTION_RECORD *pExceptionRecord, // 异常状态描述 EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame, // 异常注册框架 CONTEXT *pContextRecord, // 返回线程上下文 PVOID pDispatcherContext ) // 分发器上下文（系统使用，无需关注）&#123; // 1. 获取调试标志位 BYTE IsBeginDebug = false; __asm &#123; push eax; mov eax, dword ptr fs:[0x30]; // 获取PEB mov al,byte ptr ds:[eax+2]; // 获取PEB.BeginDebug mov IsBeginDebug,al; pop eax; &#125;; // 2. 备份正确的异常返回地址 g_funExceptionReturn = (void (*)())pContextRecord-&gt;Eip; // 3. 根据标志位执行不同的SEH异常处理流程 if ( IsBeginDebug ) pContextRecord-&gt;Eip = (DWORD)WrongFun; else pContextRecord-&gt;Eip = (DWORD)RightFun; // 4. 返回“已经正常处理” return ExceptionContinueExecution;&#125;EXCEPTION_DISPOSITION ExpHandel_B( EXCEPTION_RECORD *pExceptionRecord, // 异常状态描述 EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame, // 异常注册框架 CONTEXT *pContextRecord, // 返回线程上下文 PVOID pDispatcherContext ) // 分发器上下文（系统使用，无需关注）&#123; // 返回“运行下一个异常处理器” return ExceptionContinueSearch;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; // 1. 添加SEH异常链 // 以下异常链添加完成后为： // [Start] [End] // *-------------* *-------------* *------------* *------------* // | Next -------+--&gt; | Next -------+--&gt; | Next ------+--&gt; ... --&gt; | 0xFFFFFFFF | // | ExpHandel_B | | ExpHandel_A | | ?????????? | | ?????????? | // *-------------* *-------------* *------------* *------------* __asm&#123; /* 添加SEH异常链A */ push ExpHandel_A; push dword ptr fs:[0]; mov dword ptr fs:[0],esp; &#125;; __asm&#123; /* 添加SEH异常链B */ push ExpHandel_B; push dword ptr fs:[0]; mov dword ptr fs:[0],esp; &#125;; // 2. 人为制造异常 int *pTest = nullptr; *pTest = 0; return 0;&#125;","categories":[],"tags":[]}]}