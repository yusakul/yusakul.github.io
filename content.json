{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"梁言","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-21T13:10:11.000Z","updated":"2018-06-21T13:10:51.701Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-21T13:09:20.000Z","updated":"2018-06-21T13:09:54.271Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"010 Editor v8.0.1_x32分析以及注册机制作","slug":"010 Editor分析","date":"2018-06-25T01:09:57.000Z","updated":"2018-06-25T01:19:58.622Z","comments":true,"path":"2018/06/25/010 Editor分析/","link":"","permalink":"http://yoursite.com/2018/06/25/010 Editor分析/","excerpt":"","text":"环境以及工具 Window7_x32 010 Editor v8.0.1_x32 OD VS2017 第一步 找到判断注册结构跳转 使用OD打开010editor，进入到注册界面，先尝试输入随意的ID和Key，获取弹出的提示信息字符串","categories":[],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"http://yoursite.com/tags/逆向工程/"}]},{"title":"Android游戏分析","slug":"Android游戏分析","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-23T05:59:22.201Z","comments":true,"path":"2018/06/21/Android游戏分析/","link":"","permalink":"http://yoursite.com/2018/06/21/Android游戏分析/","excerpt":"","text":"","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"验证异常处理调用顺序","slug":"验证异常处理调用顺序","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:55:13.272Z","comments":true,"path":"2018/06/21/验证异常处理调用顺序/","link":"","permalink":"http://yoursite.com/2018/06/21/验证异常处理调用顺序/","excerpt":"","text":"验证异常处理调用顺序：VEH –&gt; SEH –&gt; VCH 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"stdafx.h\"#include &lt;windows.h&gt;LONG WINAPI vch(EXCEPTION_POINTERS* pExcept)&#123; printf(\"vch\\n\"); return EXCEPTION_CONTINUE_SERCH;&#125;LONG WINAPI veh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"veh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI seh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"seh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI ueh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"ueh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; AddVectoredContinueHandler(TRUE, vch); AddVectoreExceptionHandler(TRUE, veh); //在64位系统系下，当程序被调用时，UEH不会被调用，不被调试才会被调用 //在32位系统下，被调试时也会被调用 SetUnhandledExceptionFilter(ueh); __try&#123; *(int*)0=0; &#125; __except(seh(GetExceptionInformation()))&#123; &#125; return 0;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"DLL注入+VEH 的方式处理异常 （一）","slug":"DLL注入 + VEH 的方式处理异常","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:53:13.051Z","comments":true,"path":"2018/06/21/DLL注入 + VEH 的方式处理异常/","link":"","permalink":"http://yoursite.com/2018/06/21/DLL注入 + VEH 的方式处理异常/","excerpt":"","text":"test.cpp 12345678910111213#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; printf(\"输入\\n\"); int a, b; scanf_s(\"%d\", &amp;a); b = 1 / a; printf(\"%d\\n\", b); system(\"pause\"); return 0;&#125; dllmain.dll 1234567891011121314151617181920212223242526272829303132333435363738// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"stdafx.h\"#include \"stdio.h\"#include \"windows.h\"LONG WINAPI veh(EXCEPTION_POINTERS* pExce)&#123; if (pExce-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; pExce-&gt;ContextRecord-&gt;Eip += 3; printf(\"fdsf\\n\"); return EXCEPTION_CONTINUE_EXECUTION; &#125; return EXCEPTION_CONTINUE_SEARCH;&#125; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: //1. 将异常处理函数注册到系统 AddVectoredExceptionHandler(TRUE, veh); printf(\"注册异常处理函数成功！\\n\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 注入器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 远程注入.cpp: 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include \"windows.h\"bool injectDll(DWORD dwPid, const char* pszDllPath);int main()&#123; DWORD dwPid; char szDllPath[MAX_PATH] = &#123; \"C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\VEH_Dll\\\\Debug\\\\VEH_Dll.dll\"&#125;; printf(\"输入要注入到的进程PID：\"); scanf_s(\"%d[*]\", &amp;dwPid); injectDll(dwPid, szDllPath); return 0;&#125;bool injectDll(DWORD dwPid, const char* pszDllPath)&#123; bool bRet = false; HANDLE hProcess = 0; HANDLE hRemoteThread = 0; LPVOID pRemoteBuff = NULL; SIZE_T dwWrite = 0; DWORD dwSize = 0; //打开进程 hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,/*创建线程和写入内存权限*/ FALSE, dwPid/*进程ID*/); if (hProcess == NULL) &#123; printf(\"打开进程失败,可能由于本程序的权限太低,请以管理员身份运行再尝试\\n\"); goto _EXIT; &#125; //1. 在远程进程上开辟内存空间 pRemoteBuff = VirtualAllocEx( hProcess, NULL, 64*1024,/*大小：64Kb*/ MEM_COMMIT,/*预定并提交*/ PAGE_EXECUTE_READWRITE/*可读可写可执行的属性*/ ); if (pRemoteBuff == NULL) &#123; printf(\"在远程进程上开辟空降失败\\n\"); goto _EXIT; &#125; //2. 将DLL路径写入到新开的内存空间中 dwSize = strlen(pszDllPath) + 1; WriteProcessMemory( hProcess, pRemoteBuff,/* 要写入的地址 */ pszDllPath, /* 要写入的内容的地址*/ dwSize, /* 写入的字节数 */ &amp;dwWrite /* 输入：函数实际写入的字节数*/ ); if (dwWrite != dwSize) &#123; printf(\"写入Dll路径失败\\n\"); goto _EXIT; &#125; //3. 创建远程线程 // 远程线程创建成功后,DLL就会被加载,DLL被加载后DllMain函数 // 就会被执行,如果想要执行什么代码,就在DllMain中调用即可. hRemoteThread = CreateRemoteThread( hProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, /* 线程回调函数 */ pRemoteBuff, /* 回调函数参数 */ 0, 0); // 等待远程线程退出. // 退出了才释放远程进程的内存空间. WaitForSingleObject(hRemoteThread, -1); bRet = true;_EXIT: // 释放远程进程的内存 VirtualFreeEx(hProcess, pRemoteBuff, 0, MEM_RELEASE); // 关闭进程句柄 CloseHandle(hProcess); return bRet;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","slug":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:56:51.840Z","comments":true,"path":"2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","link":"","permalink":"http://yoursite.com/2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","excerpt":"","text":"KiTrap03： （1）处理int3异常的函数为KITrap03 （2）在开始异常处理之初，先构造TRAP_FRAME陷阱帧结构，陷阱帧是指一个结构体，用来保存系统调用、中断、异常发生时的寄存器现场，方便以后回到用户空间 / 回到中断处时，回复那些寄存器的值，继续执行 （3）注意到KiTrap03实际上调用了CommonDispatchException CommonDisPatchException： （1）判断是用户异常还是内核异常使用的是CS段寄存器的最后两位 （2）构件了一个异常记录的结构 （3）之后实际上调用了KiDispatchException来处理异常 KiDispatchException： （1）该函数用于分发异常，根据异常所产生的模式找到异常的函数 （2）如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常 （3）如果异常发生在用户模式，则函数会将异常记录、异常栈帧 和 陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常。 KiUserExceptionDispatcher： （1）函数第一个参数为异常类型，第二个参数为产生异常时的上下文记录 （2）KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]}]}