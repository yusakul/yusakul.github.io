{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"梁言","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-21T13:10:11.000Z","updated":"2018-06-21T13:10:51.701Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-21T13:09:20.000Z","updated":"2018-06-21T13:09:54.271Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"010 Editor v8.0.1_x32分析以及注册机制作","slug":"010 Editor分析","date":"2018-06-25T01:09:57.000Z","updated":"2018-06-26T00:45:04.354Z","comments":true,"path":"2018/06/25/010 Editor分析/","link":"","permalink":"http://yoursite.com/2018/06/25/010 Editor分析/","excerpt":"","text":"环境以及工具 Window7_x32 010 Editor v8.0.1_x32 OD VS2017 第一步 找到判断注册结果的关键跳转和关键函数 使用OD打开010editor，进入到注册界面，先尝试输入随意的ID和Key，获取弹出的提示信息字符串 尝试在OD中搜索如下字符 “Invalid name or password.”，搜索结果如下 发现存在大量提示信息，我们在其中找到注册成功的提示信息，（上图红框：感谢购买010editor），双击查看反汇编窗口，见下图。 往上查看判断注册成功的关键跳转 我们发现地址为00DD5926处跳转JNZ 010Edito.00DD5A58应该为关键跳转，下方可以找到输出字符串”Password accepted. This ….”， 而其跳转地址处汇编代码为输出”Password accepted….” （010editor使用QT界面库编写 ，我们可以猜测出push字符串随后的函数应为输出字符串） 回到关键跳转00DD5926处，判断密码为正确的条件为EDI = 0xDB，而EDI的值是EAX给的，而EAX为函数010Edito.00409C9B的返回值，这个函数可能为验证Key的关键函数，而我们动态调试发现有跳转直接跳转到cmp edi,0xdb。 同样为函数010Edito.00409C9B，现在可以认为这是关键函数，此时EDI的值为0x177，为了验证此跳转为关键跳转，我们把EDI的值修改为0xDB。 之后F9运行 验证成功！接下来我们进入函数分析。 第二步 分析关键函数 函数010Edito.00409C9B，参数情况为： arg1 = 0x9 ； arg2 = 0x4389； 从下往上看，找到需要的0xDB，而跳转条件是eax = 0x2D， 为函数010Edito.0040A826的返回值。 进入函数，该函数作用为将key取出，放在在局部变量数组中，数组起始地址为ebx-24 1234567891011&gt; key[0 ] = [ebx-24]=0x12&gt; key[1 ] = [ebx-23]=0x34&gt; key[2 ] = [ebx-22]=0x56&gt; key[3 ] = [ebx-21]=0x78&gt; key[4 ] = [ebx-20]=0x90&gt; key[5 ] = [ebx-1F]=0x12&gt; key[6 ] = [ebx-1E]=0x34&gt; key[7 ] = [ebx-1D]=0x56&gt; key[8 ] = [ebx-1C]=0x78&gt; key[9 ] = [ebx-1B]=0x90&gt; 密钥数组对应如上，该处汇编代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&gt; 013BDC5D . 8A5D DF MOV BL,BYTE PTR SS:[EBP-0x21] // key[3]&gt; 013BDC60 . 8A7D E1 MOV BH,BYTE PTR SS:[EBP-0x1F] // key[5]&gt; 013BDC63 . 80FB 9C CMP BL,0x9C // 是否等于0x9c&gt; 013BDC66 . 75 70 JNZ SHORT 010Edito.013BDCD8 // 跳转到是否等于FC&gt; 013BDC68 . 8A45 DC MOV AL,BYTE PTR SS:[EBP-0x24] // key[0]&gt; 013BDC6B . 3245 E2 XOR AL,BYTE PTR SS:[EBP-0x1E] // key[0]^key[6]&gt; 013BDC6E . 8845 E8 MOV BYTE PTR SS:[EBP-0x18],AL //&gt; 013BDC71 . 8A45 DD MOV AL,BYTE PTR SS:[EBP-0x23] // key[1]&gt; 013BDC74 . 3245 E3 XOR AL,BYTE PTR SS:[EBP-0x1D] // key[1]^key[7]&gt; 013BDC77 . FF75 E8 PUSH DWORD PTR SS:[EBP-0x18]&gt; 013BDC7A . 0FB6C8 MOVZX ECX,AL&gt; 013BDC7D . B8 00010000 MOV EAX,0x100&gt; 013BDC82 . 66:0FAFC8 IMUL CX,AX // (key[1]^key[7])*100&gt; 013BDC86 . 8A45 DE MOV AL,BYTE PTR SS:[EBP-0x22] // key[2]&gt; 013BDC89 . 32C7 XOR AL,BH // key[2]^key[5]&gt; 013BDC8B . 0FB6C0 MOVZX EAX,AL&gt; 013BDC8E . 66:03C8 ADD CX,AX &gt; //cx = (key[1]^key[7])*100 + key[2]^key[5]&gt; 013BDC91 . 0FB7F1 MOVZX ESI,CX&gt; 013BDC94 . E8 AB9904FF CALL 010Edito.00407644 &gt; 013BD0B0 /&gt; \\55 PUSH EBP&gt; 013BD0B1 |. 8BEC MOV EBP,ESP&gt; 013BD0B3 |. 8B45 08 MOV EAX,[ARG.1] &gt; // eax = key[0]^key[6] &gt; 013BD0B6 |. 34 18 XOR AL,0x18 &gt; // al = key[0]^key[6]^0x18 &gt; 013BD0B8 |. 04 3D ADD AL,0x3D &gt; // al = key[0]^key[6]^0x18 + 0x3D&gt; 013BD0BA |. 34 A7 XOR AL,0xA7 &gt; // al =(key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BD0BC |. 5D POP EBP &gt; 013BD0BD \\. C3 RETN&gt; &gt; 013BDC99 . 0FB6C0 MOVZX EAX,AL&gt; 013BDC9C . 56 PUSH ESI &gt; // esi = (key[1]^key[7])*100 + key[2]^key[5]&gt; 013BDC9D . 8947 1C MOV DWORD PTR DS:[EDI+0x1C],EAX&gt; 013BDCA0 . E8 23A704FF CALL 010Edito.004083C8&gt; 013BD020 /&gt; \\55 PUSH EBP&gt; 013BD021 |. 8BEC MOV EBP,ESP&gt; 013BD023 |. 8B45 08 MOV EAX,[ARG.1] &gt; //eax=(key[1]^key[7])*100+key[2]^key[5]&gt; 013BD026 |. B9 0B000000 MOV ECX,0xB &gt; // ecx = 0xB&gt; 013BD02B |. 35 92780000 XOR EAX,0x7892 &gt; //eax=((key[1]^key[7])*100+key[2]^key[5])^0x7892&gt; 013BD030 |. 05 304D0000 ADD EAX,0x4D30&gt; //eax=((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30&gt; 013BD035 |. 35 21340000 XOR EAX,0x3421&gt; //eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BD03A |. 0FB7C0 MOVZX EAX,AX&gt; 013BD03D |. 99 CDQ&gt; 013BD03E |. F7F9 IDIV ECX &gt; //eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421/0xB&gt; 013BD040 |. 85D2 TEST EDX,EDX //ecx/eax的余数否为0&gt; 013BD042 |. 74 02 JE SHORT 010Edito.013BD046 //如果余数不为0,清零eax&gt; 013BD044 |. 33C0 XOR EAX,EAX&gt; 013BD046 |&gt; 5D POP EBP &gt; 013BD047 \\. C3 RETN&gt; &gt; 013BDCA5 . 8B4F 1C MOV ECX,DWORD PTR DS:[EDI+0x1C]&gt; // ecx = (key[0]^key[6]^0x18+0x3D)^0xA7&gt; 013BDCA8 . 83C4 08 ADD ESP,0x8 &gt; 013BDCAB . 0FB7C0 MOVZX EAX,AX&gt; //eax=(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BDCAE . 8947 20 MOV DWORD PTR DS:[EDI+0x20],EAX&gt; //[EDI+0x20] =(((key[1]^key[7])*100+key[2]^key[5])^0x7892 + 0x4D30)^0x3421&gt; 013BDCB1 . 85C9 TEST ECX,ECX &gt; 013BDCB3 . 0F84 BC010000 JE 010Edito.013BDE75 //ecx = 0 则eax=E7返回&gt; 013BDCB9 . 85C0 TEST EAX,EAX&gt; 013BDCBB . 0F84 B4010000 JE 010Edito.013BDE75 //eax = 0 则eax=E7返回&gt; 013BDCC1 . 3D E8030000 CMP EAX,0x3E8&gt; 013BDCC6 . 0F87 A9010000 JA 010Edito.013BDE75 //eax &gt; 0x3E8 则eax=E7返回&gt; 013BDCCC . 83F9 02 CMP ECX,0x2 //ecx小于等于1时，借位cf=1,否则cf=0&gt; 013BDCCF . 1BF6 SBB ESI,ESI // esi=esi-esi-CF=-cf&gt; 013BDCD1 . 23F1 AND ESI,ECX // esi = esi &amp; ecx &gt; 013BDCD3 . E9 B3000000 JMP 010Edito.013BDD8B&gt;","categories":[],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"http://yoursite.com/tags/逆向工程/"}]},{"title":"Android游戏分析","slug":"Android游戏分析","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-23T05:59:22.201Z","comments":true,"path":"2018/06/21/Android游戏分析/","link":"","permalink":"http://yoursite.com/2018/06/21/Android游戏分析/","excerpt":"","text":"","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","slug":"分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:56:51.840Z","comments":true,"path":"2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","link":"","permalink":"http://yoursite.com/2018/06/21/分析KiTrap03, CommonDisPatchException, KiDispatchException, KiUserExceptionDispatcher/","excerpt":"","text":"KiTrap03： （1）处理int3异常的函数为KITrap03 （2）在开始异常处理之初，先构造TRAP_FRAME陷阱帧结构，陷阱帧是指一个结构体，用来保存系统调用、中断、异常发生时的寄存器现场，方便以后回到用户空间 / 回到中断处时，回复那些寄存器的值，继续执行 （3）注意到KiTrap03实际上调用了CommonDispatchException CommonDisPatchException： （1）判断是用户异常还是内核异常使用的是CS段寄存器的最后两位 （2）构件了一个异常记录的结构 （3）之后实际上调用了KiDispatchException来处理异常 KiDispatchException： （1）该函数用于分发异常，根据异常所产生的模式找到异常的函数 （2）如果异常发生在内核模式，函数会直接调用一个异常处理函数直接处理异常 （3）如果异常发生在用户模式，则函数会将异常记录、异常栈帧 和 陷阱栈帧拷贝到用户模式的线程的栈（这些信息在用户态可以被修改，被修改会重新设置到线程环境上），随后函数会进入到用户态，到了用户态之后会被专门的函数去处理异常。 KiUserExceptionDispatcher： （1）函数第一个参数为异常类型，第二个参数为产生异常时的上下文记录 （2）KiUserExceptionDispatcher 的核心是对 RtlDispatchException 的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException 的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"DLL注入+VEH 的方式处理异常 （一）","slug":"DLL注入 + VEH 的方式处理异常","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:53:13.051Z","comments":true,"path":"2018/06/21/DLL注入 + VEH 的方式处理异常/","link":"","permalink":"http://yoursite.com/2018/06/21/DLL注入 + VEH 的方式处理异常/","excerpt":"","text":"test.cpp 12345678910111213#include \"stdafx.h\"#include &lt;process.h&gt;int main()&#123; printf(\"输入\\n\"); int a, b; scanf_s(\"%d\", &amp;a); b = 1 / a; printf(\"%d\\n\", b); system(\"pause\"); return 0;&#125; dllmain.dll 1234567891011121314151617181920212223242526272829303132333435363738// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"stdafx.h\"#include \"stdio.h\"#include \"windows.h\"LONG WINAPI veh(EXCEPTION_POINTERS* pExce)&#123; if (pExce-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123; pExce-&gt;ContextRecord-&gt;Eip += 3; printf(\"fdsf\\n\"); return EXCEPTION_CONTINUE_EXECUTION; &#125; return EXCEPTION_CONTINUE_SEARCH;&#125; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: //1. 将异常处理函数注册到系统 AddVectoredExceptionHandler(TRUE, veh); printf(\"注册异常处理函数成功！\\n\"); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 注入器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 远程注入.cpp: 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include \"windows.h\"bool injectDll(DWORD dwPid, const char* pszDllPath);int main()&#123; DWORD dwPid; char szDllPath[MAX_PATH] = &#123; \"C:\\\\Users\\\\Administrator\\\\source\\\\repos\\\\VEH_Dll\\\\Debug\\\\VEH_Dll.dll\"&#125;; printf(\"输入要注入到的进程PID：\"); scanf_s(\"%d[*]\", &amp;dwPid); injectDll(dwPid, szDllPath); return 0;&#125;bool injectDll(DWORD dwPid, const char* pszDllPath)&#123; bool bRet = false; HANDLE hProcess = 0; HANDLE hRemoteThread = 0; LPVOID pRemoteBuff = NULL; SIZE_T dwWrite = 0; DWORD dwSize = 0; //打开进程 hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE,/*创建线程和写入内存权限*/ FALSE, dwPid/*进程ID*/); if (hProcess == NULL) &#123; printf(\"打开进程失败,可能由于本程序的权限太低,请以管理员身份运行再尝试\\n\"); goto _EXIT; &#125; //1. 在远程进程上开辟内存空间 pRemoteBuff = VirtualAllocEx( hProcess, NULL, 64*1024,/*大小：64Kb*/ MEM_COMMIT,/*预定并提交*/ PAGE_EXECUTE_READWRITE/*可读可写可执行的属性*/ ); if (pRemoteBuff == NULL) &#123; printf(\"在远程进程上开辟空降失败\\n\"); goto _EXIT; &#125; //2. 将DLL路径写入到新开的内存空间中 dwSize = strlen(pszDllPath) + 1; WriteProcessMemory( hProcess, pRemoteBuff,/* 要写入的地址 */ pszDllPath, /* 要写入的内容的地址*/ dwSize, /* 写入的字节数 */ &amp;dwWrite /* 输入：函数实际写入的字节数*/ ); if (dwWrite != dwSize) &#123; printf(\"写入Dll路径失败\\n\"); goto _EXIT; &#125; //3. 创建远程线程 // 远程线程创建成功后,DLL就会被加载,DLL被加载后DllMain函数 // 就会被执行,如果想要执行什么代码,就在DllMain中调用即可. hRemoteThread = CreateRemoteThread( hProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, /* 线程回调函数 */ pRemoteBuff, /* 回调函数参数 */ 0, 0); // 等待远程线程退出. // 退出了才释放远程进程的内存空间. WaitForSingleObject(hRemoteThread, -1); bRet = true;_EXIT: // 释放远程进程的内存 VirtualFreeEx(hProcess, pRemoteBuff, 0, MEM_RELEASE); // 关闭进程句柄 CloseHandle(hProcess); return bRet;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]},{"title":"验证异常处理调用顺序","slug":"验证异常处理调用顺序","date":"2018-06-21T11:57:52.000Z","updated":"2018-06-22T00:55:13.272Z","comments":true,"path":"2018/06/21/验证异常处理调用顺序/","link":"","permalink":"http://yoursite.com/2018/06/21/验证异常处理调用顺序/","excerpt":"","text":"验证异常处理调用顺序：VEH –&gt; SEH –&gt; VCH 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"stdafx.h\"#include &lt;windows.h&gt;LONG WINAPI vch(EXCEPTION_POINTERS* pExcept)&#123; printf(\"vch\\n\"); return EXCEPTION_CONTINUE_SERCH;&#125;LONG WINAPI veh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"veh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI seh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"seh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;LONG WINAPI ueh(EXCEPTION_POINTERS* pExcept)&#123; printf(\"ueh\\n\"); return EXCEPTION_CONTINUE_SEARCH;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; AddVectoredContinueHandler(TRUE, vch); AddVectoreExceptionHandler(TRUE, veh); //在64位系统系下，当程序被调用时，UEH不会被调用，不被调试才会被调用 //在32位系统下，被调试时也会被调用 SetUnhandledExceptionFilter(ueh); __try&#123; *(int*)0=0; &#125; __except(seh(GetExceptionInformation()))&#123; &#125; return 0;&#125;","categories":[],"tags":[{"name":"调试与异常","slug":"调试与异常","permalink":"http://yoursite.com/tags/调试与异常/"}]}]}